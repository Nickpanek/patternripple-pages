<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PatternRipple | Colorway Generator</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=DM+Mono:wght@400;500&family=Playfair+Display:wght@700&display=swap');

        :root {
            --bg: #0e0e0e;
            --surface: #1a1a1a;
            --border: #2a2a2a;
            --accent: #c8f065;
            --text: #e8e8e8;
            --muted: #666;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }

        body {
            font-family: 'DM Mono', monospace;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
            padding: 40px 20px;
        }

        .app {
            max-width: 900px;
            margin: 0 auto;
        }

        header {
            margin-bottom: 40px;
            border-bottom: 1px solid var(--border);
            padding-bottom: 20px;
        }

        h1 {
            font-family: 'Playfair Display', serif;
            font-size: 2.2rem;
            color: var(--accent);
            letter-spacing: -1px;
        }

        .subtitle {
            color: var(--muted);
            font-size: 0.8rem;
            margin-top: 4px;
        }

        .upload-zone {
            border: 1px dashed var(--border);
            border-radius: 4px;
            padding: 40px;
            text-align: center;
            cursor: pointer;
            transition: border-color 0.2s, background 0.2s;
            margin-bottom: 30px;
            position: relative;
        }

        .upload-zone:hover, .upload-zone.dragover {
            border-color: var(--accent);
            background: rgba(200,240,101,0.03);
        }

        .upload-zone input {
            position: absolute;
            inset: 0;
            opacity: 0;
            cursor: pointer;
            width: 100%;
            height: 100%;
        }

        .upload-label {
            font-size: 0.85rem;
            color: var(--muted);
        }

        .upload-label span {
            color: var(--accent);
        }

        #preview-wrap {
            display: none;
            margin-bottom: 30px;
        }

        #preview-img {
            max-width: 100%;
            max-height: 250px;
            border: 1px solid var(--border);
            border-radius: 4px;
            display: block;
        }

        .section-label {
            font-size: 0.7rem;
            color: var(--muted);
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 12px;
        }

        #palette-section {
            display: none;
            margin-bottom: 30px;
        }

        .palette-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        .palette-slot {
            display: flex;
            align-items: center;
            gap: 8px;
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 8px 12px;
        }

        .swatch {
            width: 28px;
            height: 28px;
            border-radius: 3px;
            border: 1px solid rgba(255,255,255,0.1);
            flex-shrink: 0;
        }

        .slot-info {
            font-size: 0.72rem;
            color: var(--muted);
        }

        .slot-hex {
            color: var(--text);
            font-size: 0.78rem;
        }

        .arrow {
            color: var(--accent);
            font-size: 0.9rem;
        }

        .replace-input {
            width: 36px;
            height: 36px;
            border: 1px solid var(--border);
            border-radius: 3px;
            cursor: pointer;
            background: none;
            padding: 0;
        }

        .add-colorway-btn {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            background: none;
            border: 1px dashed var(--border);
            color: var(--accent);
            font-family: 'DM Mono', monospace;
            font-size: 0.78rem;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            transition: border-color 0.2s;
            margin-top: 12px;
        }

        .add-colorway-btn:hover { border-color: var(--accent); }

        #colorways-section {
            display: none;
            margin-bottom: 30px;
        }

        .colorway-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .colorway-row {
            display: flex;
            align-items: center;
            gap: 8px;
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 10px 14px;
            flex-wrap: wrap;
        }

        .colorway-row .cw-label {
            font-size: 0.72rem;
            color: var(--muted);
            min-width: 80px;
        }

        .cw-swatches {
            display: flex;
            gap: 4px;
            flex-wrap: wrap;
            flex: 1;
        }

        .cw-swatch-pair {
            display: flex;
            align-items: center;
            gap: 3px;
            font-size: 0.65rem;
            color: var(--muted);
        }

        .mini-swatch {
            width: 18px;
            height: 18px;
            border-radius: 2px;
            border: 1px solid rgba(255,255,255,0.08);
        }

        .remove-btn {
            background: none;
            border: none;
            color: var(--muted);
            cursor: pointer;
            font-size: 1rem;
            padding: 2px 6px;
            border-radius: 3px;
            transition: color 0.2s;
            margin-left: auto;
        }

        .remove-btn:hover { color: #ff6b6b; }

        .generate-btn {
            width: 100%;
            padding: 16px;
            background: var(--accent);
            color: #0e0e0e;
            border: none;
            border-radius: 4px;
            font-family: 'DM Mono', monospace;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            transition: opacity 0.2s;
            letter-spacing: 1px;
        }

        .generate-btn:hover { opacity: 0.88; }
        .generate-btn:disabled { opacity: 0.35; cursor: not-allowed; }

        #status {
            margin-top: 14px;
            font-size: 0.78rem;
            color: var(--muted);
            text-align: center;
            min-height: 20px;
        }

        .progress-bar {
            width: 100%;
            height: 2px;
            background: var(--border);
            border-radius: 2px;
            margin-top: 10px;
            overflow: hidden;
            display: none;
        }

        .progress-fill {
            height: 100%;
            background: var(--accent);
            width: 0%;
            transition: width 0.2s;
        }

        .tolerance-row {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 20px;
        }

        .tolerance-row label {
            font-size: 0.75rem;
            color: var(--muted);
        }

        #tolerance {
            flex: 1;
            accent-color: var(--accent);
        }

        #tol-val {
            font-size: 0.75rem;
            color: var(--accent);
            min-width: 25px;
        }
    </style>
</head>
<body>
<div class="app">
    <header>
        <h1>Colorway Generator</h1>
        <div class="subtitle">palette swap — maps exact colors, not brightness</div>
    </header>

    <div class="upload-zone" id="dropZone">
        <input type="file" id="imageInput" accept="image/png,image/jpeg,image/gif">
        <div class="upload-label">Drop image here or <span>browse</span></div>
    </div>

    <div id="preview-wrap">
        <div class="section-label" style="margin-bottom:8px;">Loaded Image</div>
        <img id="preview-img" alt="preview">
    </div>

    <div id="palette-section">
        <div class="section-label">Detected Colors → Replacement</div>
        <div class="tolerance-row">
            <label>Color tolerance:</label>
            <input type="range" id="tolerance" min="0" max="60" value="15">
            <span id="tol-val">15</span>
            <label style="margin-left:8px; font-size:0.7rem; color:#444;">(higher = group similar colors)</label>
        </div>
        <div class="palette-grid" id="paletteGrid"></div>
        <button class="add-colorway-btn" id="addColorwayBtn">+ Save as Colorway</button>
    </div>

    <div id="colorways-section">
        <div class="section-label" style="margin-top:24px;">Colorways to Generate</div>
        <div class="colorway-list" id="colorwayList"></div>
    </div>

    <div style="margin-top: 24px;">
        <button class="generate-btn" id="generateBtn" disabled>Generate & Download ZIP</button>
        <div class="progress-bar" id="progressBar"><div class="progress-fill" id="progressFill"></div></div>
        <div id="status"></div>
    </div>
</div>

<canvas id="canvas" style="display:none;"></canvas>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
let originalImageData = null;
let detectedPalette = []; // [{r,g,b,hex}]
let colorways = []; // [{mappings: [{from:{r,g,b}, to:{r,g,b}}]}]

// Drag & drop
const dropZone = document.getElementById('dropZone');
dropZone.addEventListener('dragover', e => { e.preventDefault(); dropZone.classList.add('dragover'); });
dropZone.addEventListener('dragleave', () => dropZone.classList.remove('dragover'));
dropZone.addEventListener('drop', e => {
    e.preventDefault();
    dropZone.classList.remove('dragover');
    const file = e.dataTransfer.files[0];
    if (file) loadImage(file);
});

document.getElementById('imageInput').addEventListener('change', e => {
    if (e.target.files[0]) loadImage(e.target.files[0]);
});

document.getElementById('tolerance').addEventListener('input', function() {
    document.getElementById('tol-val').textContent = this.value;
    if (originalImageData) extractPalette();
});

function loadImage(file) {
    const img = new Image();
    const url = URL.createObjectURL(file);
    img.onload = () => {
        canvas.width = img.width;
        canvas.height = img.height;
        ctx.drawImage(img, 0, 0);
        originalImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

        document.getElementById('preview-img').src = url;
        document.getElementById('preview-wrap').style.display = 'block';

        extractPalette();
        URL.revokeObjectURL(url);
    };
    img.src = url;
}

function colorDistance(a, b) {
    return Math.sqrt((a.r-b.r)**2 + (a.g-b.g)**2 + (a.b-b.b)**2);
}

function rgbToHex(r, g, b) {
    return '#' + [r,g,b].map(v => v.toString(16).padStart(2,'0')).join('');
}

function extractPalette() {
    const tolerance = parseInt(document.getElementById('tolerance').value);
    const data = originalImageData.data;
    const colorCounts = {};

    // Sample every 4th pixel for speed
    for (let i = 0; i < data.length; i += 16) {
        if (data[i+3] < 128) continue; // skip transparent
        const r = data[i], g = data[i+1], b = data[i+2];
        // Quantize slightly
        const qr = Math.round(r/4)*4, qg = Math.round(g/4)*4, qb = Math.round(b/4)*4;
        const key = `${qr},${qg},${qb}`;
        colorCounts[key] = (colorCounts[key] || 0) + 1;
    }

    // Sort by frequency
    const sorted = Object.entries(colorCounts)
        .sort((a,b) => b[1]-a[1])
        .map(([k]) => {
            const [r,g,b] = k.split(',').map(Number);
            return {r,g,b};
        });

    // Cluster by tolerance
    const clusters = [];
    for (const color of sorted) {
        let found = false;
        for (const c of clusters) {
            if (colorDistance(color, c) <= tolerance) {
                found = true;
                break;
            }
        }
        if (!found) clusters.push(color);
        if (clusters.length >= 32) break;
    }

    detectedPalette = clusters.map(c => ({...c, hex: rgbToHex(c.r,c.g,c.b)}));
    renderPaletteGrid();
}

function renderPaletteGrid() {
    const grid = document.getElementById('paletteGrid');
    grid.innerHTML = '';
    document.getElementById('palette-section').style.display = 'block';

    detectedPalette.forEach((color, i) => {
        const slot = document.createElement('div');
        slot.className = 'palette-slot';
        slot.innerHTML = `
            <div class="swatch" style="background:${color.hex}"></div>
            <div>
                <div class="slot-hex">${color.hex}</div>
                <div class="slot-info">color ${i+1}</div>
            </div>
            <span class="arrow">→</span>
            <input type="color" class="replace-input" data-index="${i}" value="${color.hex}" title="Pick replacement color">
        `;
        grid.appendChild(slot);
    });
}

document.getElementById('addColorwayBtn').addEventListener('click', () => {
    const inputs = document.querySelectorAll('.replace-input');
    const mappings = [];
    inputs.forEach(input => {
        const i = parseInt(input.dataset.index);
        const from = detectedPalette[i];
        const toHex = input.value;
        const tr = parseInt(toHex.slice(1,3),16);
        const tg = parseInt(toHex.slice(3,5),16);
        const tb = parseInt(toHex.slice(5,7),16);
        mappings.push({from, to:{r:tr,g:tg,b:tb,hex:toHex}});
    });

    colorways.push({mappings});
    renderColorwayList();
    document.getElementById('generateBtn').disabled = false;
});

function renderColorwayList() {
    const list = document.getElementById('colorwayList');
    list.innerHTML = '';
    document.getElementById('colorways-section').style.display = colorways.length ? 'block' : 'none';

    colorways.forEach((cw, ci) => {
        const row = document.createElement('div');
        row.className = 'colorway-row';

        const swatches = cw.mappings.map(m => `
            <div class="cw-swatch-pair">
                <div class="mini-swatch" style="background:${m.from.hex}"></div>
                <span>→</span>
                <div class="mini-swatch" style="background:${m.to.hex}"></div>
            </div>
        `).join('');

        row.innerHTML = `
            <span class="cw-label">colorway ${ci+1}</span>
            <div class="cw-swatches">${swatches}</div>
            <button class="remove-btn" data-index="${ci}" title="Remove">×</button>
        `;
        list.appendChild(row);
    });

    list.querySelectorAll('.remove-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            colorways.splice(parseInt(btn.dataset.index), 1);
            renderColorwayList();
            if (!colorways.length) document.getElementById('generateBtn').disabled = true;
        });
    });
}

document.getElementById('generateBtn').addEventListener('click', async () => {
    const btn = document.getElementById('generateBtn');
    const status = document.getElementById('status');
    const bar = document.getElementById('progressBar');
    const fill = document.getElementById('progressFill');

    btn.disabled = true;
    bar.style.display = 'block';
    fill.style.width = '0%';

    const zip = new JSZip();
    const tolerance = parseInt(document.getElementById('tolerance').value);
    const total = colorways.length;

    for (let ci = 0; ci < total; ci++) {
        const cw = colorways[ci];
        status.textContent = `Processing colorway ${ci+1} of ${total}...`;

        // Copy original pixel data
        const newData = new ImageData(
            new Uint8ClampedArray(originalImageData.data),
            originalImageData.width,
            originalImageData.height
        );
        const d = newData.data;

        for (let i = 0; i < d.length; i += 4) {
            if (d[i+3] < 128) continue;
            const pr = d[i], pg = d[i+1], pb = d[i+2];

            let bestDist = Infinity, bestTo = null;
            for (const m of cw.mappings) {
                const dist = colorDistance({r:pr,g:pg,b:pb}, m.from);
                if (dist < bestDist) { bestDist = dist; bestTo = m.to; }
            }

            if (bestDist <= tolerance + 20 && bestTo) {
                d[i] = bestTo.r;
                d[i+1] = bestTo.g;
                d[i+2] = bestTo.b;
            }
        }

        ctx.putImageData(newData, 0, 0);
        const base64 = canvas.toDataURL('image/png').split(',')[1];
        zip.file(`colorway_${ci+1}.png`, base64, {base64: true});

        fill.style.width = `${((ci+1)/total)*100}%`;
        await new Promise(r => setTimeout(r, 10)); // let UI breathe
    }

    status.textContent = 'Zipping...';
    const blob = await zip.generateAsync({type:'blob'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'PatternRipple_Colorways.zip';
    a.click();

    status.textContent = `Done. ${total} colorway(s) downloaded.`;
    btn.disabled = false;
    fill.style.width = '100%';
});
</script>
</body>
</html>
