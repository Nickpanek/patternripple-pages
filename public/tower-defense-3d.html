<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Tower Defense - Pattern Ripple</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            background: linear-gradient(135deg, #87ceeb 0%, #a8d8f0 100%);
        }

        #gameCanvas {
            display: block;
            width: 100%;
            height: 100vh;
            cursor: pointer;
        }

        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 18px;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            z-index: 100;
        }

        #ui h2 {
            margin-bottom: 10px;
            color: #4ecca3;
        }

        #ui p {
            margin: 5px 0;
        }

        #upgradePanel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border-radius: 15px;
            color: white;
            display: none;
            z-index: 200;
            min-width: 350px;
            max-width: 500px;
            border: 2px solid #4ecca3;
        }

        #upgradePanel h3 {
            margin-bottom: 20px;
            color: #4ecca3;
            text-align: center;
        }

        #upgradePanel .stat {
            margin: 10px 0;
            display: flex;
            justify-content: space-between;
        }

        #upgradePanel .specialization {
            margin: 20px 0;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            text-align: center;
        }

        #upgradePanel .specialization-label {
            font-size: 18px;
            color: #4ecca3;
            font-weight: bold;
            margin-bottom: 10px;
        }

        #upgradePanel .upgrade-options {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 20px;
        }

        #upgradePanel .upgrade-option {
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid #4ecca3;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
        }

        #upgradePanel .upgrade-option:hover {
            background: rgba(78, 204, 163, 0.2);
            transform: scale(1.05);
        }

        #upgradePanel .upgrade-option.selected {
            background: rgba(78, 204, 163, 0.3);
            border-color: #45b393;
        }

        #upgradePanel .upgrade-option h4 {
            margin-bottom: 8px;
            color: #4ecca3;
            font-size: 14px;
        }

        #upgradePanel .upgrade-option p {
            font-size: 11px;
            color: #aaa;
            margin: 5px 0;
        }

        #upgradePanel .upgrade-option .cost {
            color: #f39c12;
            font-weight: bold;
            margin-top: 8px;
        }

        #upgradePanel button {
            width: 100%;
            padding: 12px;
            margin-top: 15px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }

        #upgradeBtn {
            background: #4ecca3;
            color: #1a1a2e;
        }

        #upgradeBtn:hover {
            background: #45b393;
            transform: scale(1.05);
        }

        #upgradeBtn:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
        }

        #closeBtn {
            background: #e74c3c;
            color: white;
        }

        #closeBtn:hover {
            background: #c0392b;
            transform: scale(1.05);
        }

        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 15px 25px;
            border-radius: 10px;
            color: white;
            text-align: center;
            backdrop-filter: blur(10px);
        }

        #waveBtn {
            background: #4ecca3;
            color: #1a1a2e;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }

        #waveBtn:hover {
            background: #45b393;
            transform: scale(1.05);
        }

        #confirmPanel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border-radius: 15px;
            color: white;
            display: none;
            z-index: 200;
            min-width: 300px;
            border: 2px solid #4ecca3;
        }

        #confirmPanel h3 {
            margin-bottom: 20px;
            color: #4ecca3;
            text-align: center;
        }

        #confirmPanel p {
            margin: 15px 0;
            text-align: center;
            font-size: 16px;
        }

        #confirmPanel .buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        #confirmPanel button {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }

        #confirmBuildBtn {
            background: #4ecca3;
            color: #1a1a2e;
        }

        #confirmBuildBtn:hover {
            background: #45b393;
            transform: scale(1.05);
        }

        #cancelBuildBtn {
            background: #e74c3c;
            color: white;
        }

        #cancelBuildBtn:hover {
            background: #c0392b;
            transform: scale(1.05);
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <div id="ui">
        <h2>Pattern Ripple TD</h2>
        <p>Gold: <span id="gold">500</span></p>
        <p>Lives: <span id="lives">20</span></p>
        <p>Wave: <span id="wave">0</span></p>
        <p style="margin-top: 10px; font-size: 14px; color: #aaa;">
            Click tiles to build towers (100g)<br>
            Click towers to upgrade
        </p>
    </div>

    <div id="upgradePanel">
        <h3>Tower Upgrade</h3>
        <div class="specialization" id="specializationInfo">
            <div class="specialization-label" id="towerSpecialization">Basic Tower</div>
        </div>
        <div class="stat">
            <span>Level:</span>
            <span id="towerLevel">1</span>
        </div>
        <div class="stat">
            <span>Range:</span>
            <span id="towerRange">3.0</span>
        </div>
        <div class="stat">
            <span>Fire Rate:</span>
            <span id="towerFireRate">1.0/s</span>
        </div>
        <div class="stat">
            <span>Damage:</span>
            <span id="towerDamage">1</span>
        </div>
        <div id="upgradeTreeSection" style="display: none;">
            <h4 style="color: #4ecca3; margin-top: 20px; text-align: center;">Choose Specialization</h4>
            <div class="upgrade-options">
                <div class="upgrade-option" data-type="rapidfire">
                    <h4>üî• Rapid Fire</h4>
                    <p>High fire rate</p>
                    <p>Lower damage</p>
                    <div class="cost">100g</div>
                </div>
                <div class="upgrade-option" data-type="sniper">
                    <h4>üéØ Sniper</h4>
                    <p>Long range</p>
                    <p>High damage</p>
                    <div class="cost">100g</div>
                </div>
                <div class="upgrade-option" data-type="frost">
                    <h4>‚ùÑÔ∏è Frost</h4>
                    <p>Slows enemies</p>
                    <p>Moderate damage</p>
                    <div class="cost">100g</div>
                </div>
                <div class="upgrade-option" data-type="splash">
                    <h4>üí• Splash</h4>
                    <p>Area damage</p>
                    <p>Hits multiple</p>
                    <div class="cost">100g</div>
                </div>
                <div class="upgrade-option" data-type="poison">
                    <h4>‚ò†Ô∏è Poison</h4>
                    <p>Damage over time</p>
                    <p>Stacking effect</p>
                    <div class="cost">100g</div>
                </div>
            </div>
        </div>
        <div id="upgradeStandardSection">
            <button id="upgradeBtn">UPGRADE (150g)</button>
        </div>
        <button id="closeBtn">CLOSE</button>
    </div>

    <div id="confirmPanel">
        <h3>Build Tower?</h3>
        <p>Cost: <span style="color: #f39c12; font-weight: bold;">100 Gold</span></p>
        <p style="font-size: 14px; color: #aaa;">Place a tower on this tile?</p>
        <div class="buttons">
            <button id="confirmBuildBtn">BUILD</button>
            <button id="cancelBuildBtn">CANCEL</button>
        </div>
    </div>

    <div id="controls">
        <button id="waveBtn">START WAVE</button>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // ============================================
        // GAME CONFIGURATION
        // ============================================
        const CONFIG = {
            GRID_SIZE: 10,
            TILE_SIZE: 1,
            ELEVATION_HEIGHT: 0.5,
            TOWER_COST: 100,
            INITIAL_GOLD: 500,
            INITIAL_LIVES: 20
        };

        // ============================================
        // PATH DEFINITION (Canyon road)
        // ============================================
        const PATH = [
            {x: 0, z: 4}, {x: 1, z: 4}, {x: 2, z: 4}, {x: 3, z: 4},
            {x: 4, z: 4}, {x: 4, z: 5}, {x: 5, z: 5}, {x: 6, z: 5},
            {x: 7, z: 5}, {x: 8, z: 5}, {x: 9, z: 5}
        ];

        // ============================================
        // ENEMY CLASS
        // ============================================
        class Enemy {
            constructor(scene, path, wave) {
                this.scene = scene;
                this.path = path;
                this.pathIndex = 0;

                // Make first 2 waves easier with less health
                if (wave === 1) {
                    this.health = 2;
                } else if (wave === 2) {
                    this.health = 3;
                } else {
                    this.health = 3 + wave * 1.5;
                }

                this.maxHealth = this.health;
                this.baseSpeed = 0.012 + (wave * 0.0015);
                this.speed = this.baseSpeed;
                this.reward = 10 + wave * 2;
                this.alive = true;
                this.slowUntil = 0;
                this.poisonStacks = [];

                // Create enemy mesh (colored sphere)
                const geometry = new THREE.SphereGeometry(0.3, 16, 16);
                const hue = (wave * 0.1) % 1;
                const material = new THREE.MeshStandardMaterial({
                    color: new THREE.Color().setHSL(hue, 0.9, 0.6),
                    emissive: new THREE.Color().setHSL(hue, 0.9, 0.4),
                    metalness: 0.3,
                    roughness: 0.6
                });
                this.mesh = new THREE.Mesh(geometry, material);

                // Start at first path position
                const startPos = this.path[0];
                this.mesh.position.set(
                    startPos.x - CONFIG.GRID_SIZE/2 + 0.5,
                    0.3,
                    startPos.z - CONFIG.GRID_SIZE/2 + 0.5
                );

                this.scene.add(this.mesh);

                // Create health bar
                this.createHealthBar();
            }

            createHealthBar() {
                const barWidth = 0.5;
                const barHeight = 0.1;

                // Background
                const bgGeometry = new THREE.PlaneGeometry(barWidth, barHeight);
                const bgMaterial = new THREE.MeshBasicMaterial({ color: 0x333333 });
                this.healthBarBg = new THREE.Mesh(bgGeometry, bgMaterial);

                // Foreground
                const fgGeometry = new THREE.PlaneGeometry(barWidth, barHeight);
                const fgMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
                this.healthBar = new THREE.Mesh(fgGeometry, fgMaterial);

                this.healthBarBg.position.y = 0.8;
                this.healthBar.position.y = 0.8;
                this.healthBar.position.z = 0.01;

                this.mesh.add(this.healthBarBg);
                this.mesh.add(this.healthBar);
            }

            updateHealthBar() {
                const healthPercent = this.health / this.maxHealth;
                this.healthBar.scale.x = healthPercent;
                this.healthBar.position.x = -0.25 * (1 - healthPercent);

                // Color transition from green to red
                const color = new THREE.Color();
                color.setHSL(healthPercent * 0.3, 1, 0.5);
                this.healthBar.material.color = color;
            }

            applySlow(amount, duration) {
                this.slowUntil = Math.max(this.slowUntil, Date.now() + duration);
                this.speed = this.baseSpeed * (1 - amount);
            }

            applyPoison(damage, duration) {
                this.poisonStacks.push({
                    damage: damage,
                    endTime: Date.now() + duration,
                    lastTick: Date.now()
                });
            }

            takeDamage(amount) {
                this.health -= amount;
                this.updateHealthBar();

                if (this.health <= 0) {
                    this.alive = false;
                    return true; // Enemy killed
                }
                return false;
            }

            update() {
                if (!this.alive) return false;

                // Update slow effect
                if (Date.now() > this.slowUntil) {
                    this.speed = this.baseSpeed;
                }

                // Update poison effects
                const currentTime = Date.now();
                for (let i = this.poisonStacks.length - 1; i >= 0; i--) {
                    const poison = this.poisonStacks[i];
                    if (currentTime > poison.endTime) {
                        this.poisonStacks.splice(i, 1);
                    } else if (currentTime - poison.lastTick >= 500) {
                        poison.lastTick = currentTime;
                        this.takeDamage(poison.damage);
                    }
                }

                const currentTarget = this.path[this.pathIndex];
                const targetWorldPos = new THREE.Vector3(
                    currentTarget.x - CONFIG.GRID_SIZE/2 + 0.5,
                    0.3,
                    currentTarget.z - CONFIG.GRID_SIZE/2 + 0.5
                );

                const direction = targetWorldPos.clone().sub(this.mesh.position);
                const distance = direction.length();

                if (distance < 0.1) {
                    this.pathIndex++;
                    if (this.pathIndex >= this.path.length) {
                        this.alive = false;
                        return 'escaped'; // Enemy reached the end
                    }
                } else {
                    direction.normalize();
                    this.mesh.position.add(direction.multiplyScalar(this.speed));
                }

                return true;
            }

            destroy() {
                this.scene.remove(this.mesh);
                this.mesh.geometry.dispose();
                this.mesh.material.dispose();
                if (this.healthBar) {
                    this.healthBar.geometry.dispose();
                    this.healthBar.material.dispose();
                }
                if (this.healthBarBg) {
                    this.healthBarBg.geometry.dispose();
                    this.healthBarBg.material.dispose();
                }
            }
        }

        // ============================================
        // TOWER CLASS
        // ============================================
        class Tower {
            constructor(scene, gridX, gridZ) {
                this.scene = scene;
                this.gridX = gridX;
                this.gridZ = gridZ;
                this.level = 1;
                this.range = 3.0;
                this.fireRate = 1.0; // Shots per second
                this.damage = 1;
                this.lastFireTime = 0;
                this.upgradeCost = 150;
                this.specialization = null;

                // Specialization stats
                this.slowAmount = 0;
                this.slowDuration = 0;
                this.poisonDamage = 0;
                this.poisonDuration = 0;
                this.splashRadius = 0;

                // Create tower mesh (box on elevated platform)
                const geometry = new THREE.BoxGeometry(0.6, 0.8, 0.6);
                const material = new THREE.MeshStandardMaterial({
                    color: 0x3498db,
                    metalness: 0.5,
                    roughness: 0.5
                });
                this.mesh = new THREE.Mesh(geometry, material);

                const worldPos = this.gridToWorld(gridX, gridZ);
                this.mesh.position.set(worldPos.x, CONFIG.ELEVATION_HEIGHT + 0.4, worldPos.z);

                this.scene.add(this.mesh);

                // Create range indicator (optional, can be toggled)
                this.createRangeIndicator();
            }

            createRangeIndicator() {
                const geometry = new THREE.RingGeometry(this.range - 0.1, this.range, 32);
                const material = new THREE.MeshBasicMaterial({
                    color: 0x3498db,
                    transparent: true,
                    opacity: 0.15,
                    side: THREE.DoubleSide
                });
                this.rangeIndicator = new THREE.Mesh(geometry, material);
                this.rangeIndicator.rotation.x = -Math.PI / 2;
                this.rangeIndicator.position.y = 0.1;
                this.mesh.add(this.rangeIndicator);
                this.rangeIndicator.visible = false;
            }

            gridToWorld(x, z) {
                return {
                    x: x - CONFIG.GRID_SIZE/2 + 0.5,
                    z: z - CONFIG.GRID_SIZE/2 + 0.5
                };
            }

            specialize(type) {
                this.specialization = type;
                this.level = 2;
                this.upgradeCost = 150;
                this.maxLevel = 5;

                switch(type) {
                    case 'rapidfire':
                        this.fireRate = 3.0;
                        this.damage = 1;
                        this.range = 2.5;
                        this.mesh.material.color.setHex(0xff6b6b);
                        break;
                    case 'sniper':
                        this.fireRate = 0.5;
                        this.damage = 5;
                        this.range = 6.0;
                        this.mesh.material.color.setHex(0x4a90e2);
                        break;
                    case 'frost':
                        this.fireRate = 1.2;
                        this.damage = 1;
                        this.range = 3.5;
                        this.slowAmount = 0.5;
                        this.slowDuration = 2000;
                        this.mesh.material.color.setHex(0x74b9ff);
                        break;
                    case 'splash':
                        this.fireRate = 0.8;
                        this.damage = 2;
                        this.range = 3.5;
                        this.splashRadius = 1.5;
                        this.mesh.material.color.setHex(0xff7f50);
                        break;
                    case 'poison':
                        this.fireRate = 1.0;
                        this.damage = 1;
                        this.range = 3.0;
                        this.poisonDamage = 0.5;
                        this.poisonDuration = 3000;
                        this.mesh.material.color.setHex(0x6c5ce7);
                        break;
                }

                // Update range indicator
                this.rangeIndicator.geometry.dispose();
                const geometry = new THREE.RingGeometry(this.range - 0.1, this.range, 32);
                this.rangeIndicator.geometry = geometry;
            }

            upgrade() {
                // Check if at max level
                if (this.maxLevel && this.level >= this.maxLevel) {
                    return false;
                }

                this.level++;

                // Scale upgrade cost: 150 -> 250 -> 400 -> 650
                this.upgradeCost = Math.floor(this.upgradeCost * 1.7);

                if (!this.specialization) {
                    // Basic tower upgrade
                    this.range += 0.5;
                    this.fireRate += 0.3;
                    this.damage += 1;
                } else {
                    // Specialized tower upgrade
                    switch(this.specialization) {
                        case 'rapidfire':
                            this.fireRate += 0.8;
                            this.damage += 0.5;
                            break;
                        case 'sniper':
                            this.damage += 3;
                            this.range += 0.5;
                            break;
                        case 'frost':
                            this.slowAmount = Math.min(0.8, this.slowAmount + 0.1);
                            this.slowDuration += 500;
                            this.damage += 0.5;
                            break;
                        case 'splash':
                            this.damage += 1;
                            this.splashRadius += 0.3;
                            break;
                        case 'poison':
                            this.poisonDamage += 0.3;
                            this.poisonDuration += 500;
                            this.damage += 0.5;
                            break;
                    }
                }

                // Update range indicator
                this.rangeIndicator.geometry.dispose();
                const geometry = new THREE.RingGeometry(this.range - 0.1, this.range, 32);
                this.rangeIndicator.geometry = geometry;

                return true;
            }

            findTarget(enemies) {
                let furthestEnemy = null;
                let maxDistance = 0;

                for (const enemy of enemies) {
                    if (!enemy.alive) continue;

                    const distance = this.mesh.position.distanceTo(enemy.mesh.position);
                    if (distance <= this.range && enemy.pathIndex > maxDistance) {
                        maxDistance = enemy.pathIndex;
                        furthestEnemy = enemy;
                    }
                }

                return furthestEnemy;
            }

            shoot(target, currentTime, enemies) {
                const timeSinceLastShot = (currentTime - this.lastFireTime) / 1000;
                if (timeSinceLastShot < 1 / this.fireRate) return null;

                this.lastFireTime = currentTime;

                // Rotate tower to face target
                this.mesh.lookAt(target.mesh.position);

                // Apply damage to target
                target.takeDamage(this.damage);

                // Apply special effects
                if (this.specialization === 'frost') {
                    target.applySlow(this.slowAmount, this.slowDuration);
                }

                if (this.specialization === 'poison') {
                    target.applyPoison(this.poisonDamage, this.poisonDuration);
                }

                if (this.specialization === 'splash' && this.splashRadius > 0) {
                    // Deal splash damage to nearby enemies
                    for (const enemy of enemies) {
                        if (enemy === target || !enemy.alive) continue;
                        const distance = target.mesh.position.distanceTo(enemy.mesh.position);
                        if (distance <= this.splashRadius) {
                            enemy.takeDamage(this.damage * 0.5);
                        }
                    }
                }

                // Return shot data for visual representation
                return {
                    from: this.mesh.position.clone(),
                    to: target.mesh.position.clone(),
                    specialization: this.specialization
                };
            }

            update(enemies, currentTime) {
                const target = this.findTarget(enemies);
                if (target) {
                    return this.shoot(target, currentTime, enemies);
                }
                return null;
            }

            showRange(visible) {
                this.rangeIndicator.visible = visible;
            }

            destroy() {
                this.scene.remove(this.mesh);
                this.mesh.geometry.dispose();
                this.mesh.material.dispose();
                this.rangeIndicator.geometry.dispose();
                this.rangeIndicator.material.dispose();
            }
        }

        // ============================================
        // PROJECTILE EFFECT
        // ============================================
        class Projectile {
            constructor(scene, from, to, specialization) {
                this.scene = scene;
                this.lifetime = 200; // milliseconds
                this.createdAt = Date.now();

                // Choose color based on specialization
                let color = 0xffff00;
                switch(specialization) {
                    case 'rapidfire': color = 0xff6b6b; break;
                    case 'sniper': color = 0x4a90e2; break;
                    case 'frost': color = 0x74b9ff; break;
                    case 'splash': color = 0xff7f50; break;
                    case 'poison': color = 0x6c5ce7; break;
                }

                // Create line for projectile
                const geometry = new THREE.BufferGeometry().setFromPoints([from, to]);
                const material = new THREE.LineBasicMaterial({
                    color: color,
                    linewidth: 3
                });
                this.line = new THREE.Line(geometry, material);
                this.scene.add(this.line);
            }

            update() {
                const age = Date.now() - this.createdAt;
                if (age > this.lifetime) {
                    this.destroy();
                    return false;
                }

                // Fade out
                this.line.material.opacity = 1 - (age / this.lifetime);
                this.line.material.transparent = true;
                return true;
            }

            destroy() {
                this.scene.remove(this.line);
                this.line.geometry.dispose();
                this.line.material.dispose();
            }
        }

        // ============================================
        // GAME MANAGER
        // ============================================
        class GameManager {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.raycaster = new THREE.Raycaster();
                this.mouse = new THREE.Vector2();

                this.grid = [];
                this.towers = [];
                this.enemies = [];
                this.projectiles = [];

                this.gold = CONFIG.INITIAL_GOLD;
                this.lives = CONFIG.INITIAL_LIVES;
                this.wave = 0;
                this.waveInProgress = false;
                this.selectedTower = null;
                this.pendingPlacement = null;

                this.init();
                this.setupEventListeners();
                this.animate();
            }

            init() {
                // Scene
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x87ceeb);
                this.scene.fog = new THREE.Fog(0x87ceeb, 15, 30);

                // Orthographic Camera (45-degree isometric angle)
                const aspect = window.innerWidth / window.innerHeight;
                const frustumSize = 12;
                this.camera = new THREE.OrthographicCamera(
                    frustumSize * aspect / -2,
                    frustumSize * aspect / 2,
                    frustumSize / 2,
                    frustumSize / -2,
                    0.1,
                    1000
                );
                this.camera.position.set(10, 10, 10);
                this.camera.lookAt(0, 0, 0);

                // Renderer
                const canvas = document.getElementById('gameCanvas');
                this.renderer = new THREE.WebGLRenderer({
                    canvas,
                    antialias: true
                });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(window.devicePixelRatio);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;

                // Lights
                const ambientLight = new THREE.AmbientLight(0xffffff, 1.0);
                this.scene.add(ambientLight);

                const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
                directionalLight.position.set(5, 10, 5);
                directionalLight.castShadow = true;
                directionalLight.shadow.camera.left = -10;
                directionalLight.shadow.camera.right = 10;
                directionalLight.shadow.camera.top = 10;
                directionalLight.shadow.camera.bottom = -10;
                this.scene.add(directionalLight);

                // Create grid
                this.createGrid();

                // Update UI
                this.updateUI();
            }

            createGrid() {
                const pathSet = new Set(PATH.map(p => `${p.x},${p.z}`));

                // PLACEHOLDER TEXTURE LOADER
                // Replace this URL with your Spoonflower pattern later
                const textureLoader = new THREE.TextureLoader();
                const placeholderTexture = this.createPlaceholderTexture();
                placeholderTexture.wrapS = THREE.RepeatWrapping;
                placeholderTexture.wrapT = THREE.RepeatWrapping;
                placeholderTexture.repeat.set(1, 1);

                for (let x = 0; x < CONFIG.GRID_SIZE; x++) {
                    this.grid[x] = [];
                    for (let z = 0; z < CONFIG.GRID_SIZE; z++) {
                        const isPath = pathSet.has(`${x},${z}`);
                        const worldX = x - CONFIG.GRID_SIZE/2 + 0.5;
                        const worldZ = z - CONFIG.GRID_SIZE/2 + 0.5;

                        if (isPath) {
                            // Canyon (flat road)
                            const geometry = new THREE.BoxGeometry(
                                CONFIG.TILE_SIZE,
                                0.1,
                                CONFIG.TILE_SIZE
                            );
                            const material = new THREE.MeshStandardMaterial({
                                color: 0xd4a574,
                                roughness: 0.8
                            });
                            const tile = new THREE.Mesh(geometry, material);
                            tile.position.set(worldX, 0, worldZ);
                            tile.receiveShadow = true;
                            this.scene.add(tile);
                            this.grid[x][z] = { type: 'path', mesh: tile };
                        } else {
                            // Elevated platform (buildable)
                            const geometry = new THREE.BoxGeometry(
                                CONFIG.TILE_SIZE,
                                CONFIG.ELEVATION_HEIGHT,
                                CONFIG.TILE_SIZE
                            );
                            const material = new THREE.MeshStandardMaterial({
                                map: placeholderTexture,
                                roughness: 0.7,
                                metalness: 0.2
                            });
                            const tile = new THREE.Mesh(geometry, material);
                            tile.position.set(worldX, CONFIG.ELEVATION_HEIGHT/2, worldZ);
                            tile.receiveShadow = true;
                            tile.castShadow = true;
                            tile.userData = { gridX: x, gridZ: z, buildable: true };
                            this.scene.add(tile);
                            this.grid[x][z] = { type: 'elevated', mesh: tile, tower: null };
                        }
                    }
                }
            }

            createPlaceholderTexture() {
                // Create a simple checker pattern as placeholder
                const size = 256;
                const canvas = document.createElement('canvas');
                canvas.width = size;
                canvas.height = size;
                const ctx = canvas.getContext('2d');

                // Base color
                ctx.fillStyle = '#95c5a4';
                ctx.fillRect(0, 0, size, size);

                // Pattern
                ctx.fillStyle = '#a8d5ba';
                const cells = 8;
                const cellSize = size / cells;
                for (let i = 0; i < cells; i++) {
                    for (let j = 0; j < cells; j++) {
                        if ((i + j) % 2 === 0) {
                            ctx.fillRect(i * cellSize, j * cellSize, cellSize, cellSize);
                        }
                    }
                }

                const texture = new THREE.CanvasTexture(canvas);
                return texture;
            }

            setupEventListeners() {
                window.addEventListener('resize', () => this.onWindowResize());
                window.addEventListener('click', (e) => this.onClick(e));
                window.addEventListener('mousemove', (e) => this.onMouseMove(e));

                document.getElementById('waveBtn').addEventListener('click', () => {
                    this.startWave();
                });

                document.getElementById('upgradeBtn').addEventListener('click', () => {
                    this.upgradeTower();
                });

                document.getElementById('closeBtn').addEventListener('click', () => {
                    this.closeUpgradePanel();
                });

                document.getElementById('confirmBuildBtn').addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.confirmTowerPlacement();
                });

                document.getElementById('cancelBuildBtn').addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.cancelTowerPlacement();
                });

                // Upgrade tree specialization options
                const upgradeOptions = document.querySelectorAll('.upgrade-option');
                upgradeOptions.forEach(option => {
                    option.addEventListener('click', (e) => {
                        e.stopPropagation();
                        if (!this.selectedTower || this.selectedTower.specialization) return;

                        // Remove previous selection
                        upgradeOptions.forEach(opt => opt.classList.remove('selected'));
                        option.classList.add('selected');

                        const type = option.getAttribute('data-type');
                        this.specializeTower(type);
                    });
                });

                // Prevent clicks on panels from propagating to the game canvas
                document.getElementById('confirmPanel').addEventListener('click', (e) => {
                    e.stopPropagation();
                });

                document.getElementById('upgradePanel').addEventListener('click', (e) => {
                    e.stopPropagation();
                });
            }

            onWindowResize() {
                const aspect = window.innerWidth / window.innerHeight;
                const frustumSize = 12;
                this.camera.left = frustumSize * aspect / -2;
                this.camera.right = frustumSize * aspect / 2;
                this.camera.top = frustumSize / 2;
                this.camera.bottom = frustumSize / -2;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }

            onClick(event) {
                this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

                this.raycaster.setFromCamera(this.mouse, this.camera);

                // Check for tower clicks first
                const towerMeshes = this.towers.map(t => t.mesh);
                const towerIntersects = this.raycaster.intersectObjects(towerMeshes);

                if (towerIntersects.length > 0) {
                    const clickedTower = this.towers.find(t => t.mesh === towerIntersects[0].object);
                    if (clickedTower) {
                        this.selectTower(clickedTower);
                        return;
                    }
                }

                // Check for tile clicks (tower placement)
                const buildableTiles = [];
                for (let x = 0; x < CONFIG.GRID_SIZE; x++) {
                    for (let z = 0; z < CONFIG.GRID_SIZE; z++) {
                        const cell = this.grid[x][z];
                        if (cell.type === 'elevated' && !cell.tower) {
                            buildableTiles.push(cell.mesh);
                        }
                    }
                }

                const intersects = this.raycaster.intersectObjects(buildableTiles);

                if (intersects.length > 0) {
                    const tile = intersects[0].object;
                    if (tile.userData.buildable) {
                        this.showPlacementConfirmation(tile.userData.gridX, tile.userData.gridZ);
                        return;
                    }
                }

                // Close panels if clicking elsewhere
                if (towerIntersects.length === 0 && intersects.length === 0) {
                    this.closeUpgradePanel();
                    this.cancelTowerPlacement();
                }
            }

            onMouseMove(event) {
                this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

                this.raycaster.setFromCamera(this.mouse, this.camera);

                // Highlight buildable tiles
                for (let x = 0; x < CONFIG.GRID_SIZE; x++) {
                    for (let z = 0; z < CONFIG.GRID_SIZE; z++) {
                        const cell = this.grid[x][z];
                        if (cell.type === 'elevated' && !cell.tower) {
                            const intersects = this.raycaster.intersectObject(cell.mesh);
                            if (intersects.length > 0) {
                                cell.mesh.material.emissive.setHex(0x222222);
                            } else {
                                cell.mesh.material.emissive.setHex(0x000000);
                            }
                        }
                    }
                }
            }

            showPlacementConfirmation(gridX, gridZ) {
                if (this.gold < CONFIG.TOWER_COST) {
                    console.log('Not enough gold!');
                    return;
                }

                // Close upgrade panel if open
                this.closeUpgradePanel();

                // Store pending placement
                this.pendingPlacement = { gridX, gridZ };

                // Show confirmation panel
                document.getElementById('confirmPanel').style.display = 'block';
            }

            confirmTowerPlacement() {
                if (!this.pendingPlacement) return;

                const { gridX, gridZ } = this.pendingPlacement;
                this.placeTower(gridX, gridZ);

                // Close panel
                document.getElementById('confirmPanel').style.display = 'none';
                this.pendingPlacement = null;
            }

            cancelTowerPlacement() {
                document.getElementById('confirmPanel').style.display = 'none';
                this.pendingPlacement = null;
            }

            placeTower(gridX, gridZ) {
                if (this.gold < CONFIG.TOWER_COST) {
                    console.log('Not enough gold!');
                    return;
                }

                const cell = this.grid[gridX][gridZ];
                if (cell.type === 'elevated' && !cell.tower) {
                    this.gold -= CONFIG.TOWER_COST;
                    const tower = new Tower(this.scene, gridX, gridZ);
                    this.towers.push(tower);
                    cell.tower = tower;
                    this.updateUI();
                }
            }

            selectTower(tower) {
                // Hide range of previously selected tower
                if (this.selectedTower) {
                    this.selectedTower.showRange(false);
                }

                this.selectedTower = tower;
                tower.showRange(true);

                // Show upgrade panel
                document.getElementById('upgradePanel').style.display = 'block';
                document.getElementById('towerLevel').textContent = tower.level;
                document.getElementById('towerRange').textContent = tower.range.toFixed(1);
                document.getElementById('towerFireRate').textContent = tower.fireRate.toFixed(1) + '/s';
                document.getElementById('towerDamage').textContent = tower.damage.toFixed(1);

                // Show specialization name
                const specializationNames = {
                    rapidfire: 'üî• Rapid Fire Tower',
                    sniper: 'üéØ Sniper Tower',
                    frost: '‚ùÑÔ∏è Frost Tower',
                    splash: 'üí• Splash Tower',
                    poison: '‚ò†Ô∏è Poison Tower'
                };
                document.getElementById('towerSpecialization').textContent =
                    tower.specialization ? specializationNames[tower.specialization] : 'Basic Tower';

                // Show/hide appropriate upgrade sections
                if (tower.level === 1 && !tower.specialization) {
                    // Show specialization tree for level 1 towers
                    document.getElementById('upgradeTreeSection').style.display = 'block';
                    document.getElementById('upgradeStandardSection').style.display = 'none';
                } else {
                    // Show standard upgrade button
                    document.getElementById('upgradeTreeSection').style.display = 'none';
                    document.getElementById('upgradeStandardSection').style.display = 'block';

                    const upgradeBtn = document.getElementById('upgradeBtn');

                    // Check if at max level
                    if (tower.maxLevel && tower.level >= tower.maxLevel) {
                        upgradeBtn.textContent = 'MAX LEVEL';
                        upgradeBtn.disabled = true;
                    } else {
                        upgradeBtn.textContent = `UPGRADE (${tower.upgradeCost}g)`;
                        upgradeBtn.disabled = this.gold < tower.upgradeCost;
                    }
                }
            }

            specializeTower(type) {
                if (!this.selectedTower) return;
                if (this.gold < 100) return;

                this.gold -= 100;
                this.selectedTower.specialize(type);
                this.updateUI();

                // Close and reopen panel to update UI
                this.closeUpgradePanel();
            }

            upgradeTower() {
                if (!this.selectedTower) return;
                if (this.gold < this.selectedTower.upgradeCost) return;

                this.gold -= this.selectedTower.upgradeCost;
                const upgraded = this.selectedTower.upgrade();

                if (upgraded) {
                    this.updateUI();
                    // Update panel
                    this.selectTower(this.selectedTower);
                }
            }

            closeUpgradePanel() {
                document.getElementById('upgradePanel').style.display = 'none';
                if (this.selectedTower) {
                    this.selectedTower.showRange(false);
                    this.selectedTower = null;
                }
            }

            startWave() {
                if (this.waveInProgress) return;

                this.wave++;
                this.waveInProgress = true;
                this.updateUI();

                // Make first 2 waves easier
                let enemyCount, spawnInterval;
                if (this.wave === 1) {
                    enemyCount = 5;
                    spawnInterval = 900;
                } else if (this.wave === 2) {
                    enemyCount = 7;
                    spawnInterval = 800;
                } else {
                    enemyCount = 8 + this.wave * 3;
                    spawnInterval = 700;
                }

                for (let i = 0; i < enemyCount; i++) {
                    setTimeout(() => {
                        const enemy = new Enemy(this.scene, PATH, this.wave);
                        this.enemies.push(enemy);
                    }, i * spawnInterval);
                }

                // Check if wave is complete
                setTimeout(() => {
                    const checkWaveComplete = setInterval(() => {
                        const aliveEnemies = this.enemies.filter(e => e.alive);
                        if (aliveEnemies.length === 0) {
                            this.waveInProgress = false;
                            clearInterval(checkWaveComplete);
                        }
                    }, 500);
                }, enemyCount * spawnInterval + 5000);
            }

            updateUI() {
                document.getElementById('gold').textContent = this.gold;
                document.getElementById('lives').textContent = this.lives;
                document.getElementById('wave').textContent = this.wave;
            }

            update() {
                const currentTime = Date.now();

                // Update enemies
                for (let i = this.enemies.length - 1; i >= 0; i--) {
                    const enemy = this.enemies[i];
                    const result = enemy.update();

                    if (result === 'escaped') {
                        this.lives--;
                        this.updateUI();
                        enemy.destroy();
                        this.enemies.splice(i, 1);

                        if (this.lives <= 0) {
                            alert('Game Over! Final Wave: ' + this.wave);
                            location.reload();
                        }
                    } else if (!enemy.alive) {
                        this.gold += enemy.reward;
                        this.updateUI();
                        enemy.destroy();
                        this.enemies.splice(i, 1);
                    }
                }

                // Update towers
                for (const tower of this.towers) {
                    const shot = tower.update(this.enemies, currentTime);
                    if (shot) {
                        // Create projectile effect with specialization color
                        const projectile = new Projectile(this.scene, shot.from, shot.to, shot.specialization);
                        this.projectiles.push(projectile);
                    }
                }

                // Update projectiles
                for (let i = this.projectiles.length - 1; i >= 0; i--) {
                    if (!this.projectiles[i].update()) {
                        this.projectiles.splice(i, 1);
                    }
                }
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                this.update();
                this.renderer.render(this.scene, this.camera);
            }
        }

        // ============================================
        // START GAME
        // ============================================
        const game = new GameManager();

        console.log('üéÆ Tower Defense Game Loaded!');
        console.log('üìù To replace placeholder texture: Use TextureLoader with your pattern URL');
        console.log('üéØ To replace meshes with GLB: Use GLTFLoader instead of BoxGeometry');
    </script>
</body>
</html>
