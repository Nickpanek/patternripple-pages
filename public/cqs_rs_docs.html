<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>cqs-rs Browser Simulator - PatternRipple Labs</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            line-height: 1.6;
            color: #333;
            background: #f8f9fa;
        }
        
        header {
            background: linear-gradient(135deg, #4a90e2 0%, #357abd 100%);
            color: white;
            padding: 2rem;
            text-align: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        header h1 {
            font-size: 2.2rem;
            margin-bottom: 0.5rem;
        }
        
        .badge {
            display: inline-block;
            background: rgba(255,255,255,0.2);
            color: white;
            padding: 0.4rem 0.8rem;
            border-radius: 20px;
            font-size: 0.85rem;
            margin: 0.3rem;
        }
        
        .header-buttons {
            margin-top: 1rem;
        }
        
        .header-btn {
            display: inline-block;
            background: rgba(255,255,255,0.3);
            color: white;
            padding: 0.6rem 1.2rem;
            border-radius: 5px;
            text-decoration: none;
            font-weight: 500;
            margin: 0.3rem;
            transition: background 0.3s;
            border: 2px solid rgba(255,255,255,0.5);
            cursor: pointer;
            font-size: 0.9rem;
        }
        
        .header-btn:hover {
            background: rgba(255,255,255,0.4);
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
        }
        
        .simulator-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
            margin: 2rem 0;
        }
        
        .panel {
            background: white;
            padding: 2rem;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
        }
        
        h2 {
            color: #4a90e2;
            margin-bottom: 1rem;
            font-size: 1.5rem;
        }
        
        textarea {
            width: 100%;
            min-height: 400px;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            padding: 1rem;
            border: 2px solid #e0e0e0;
            border-radius: 5px;
            resize: vertical;
        }
        
        textarea:focus {
            outline: none;
            border-color: #4a90e2;
        }
        
        .controls {
            display: flex;
            gap: 1rem;
            margin: 1rem 0;
            flex-wrap: wrap;
            align-items: center;
        }
        
        button {
            background: #4a90e2;
            color: white;
            border: none;
            padding: 0.8rem 1.5rem;
            border-radius: 5px;
            font-size: 1rem;
            cursor: pointer;
            transition: background 0.3s;
            font-weight: 500;
        }
        
        button:hover {
            background: #357abd;
        }
        
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        
        .secondary-btn {
            background: #6c757d;
        }
        
        .secondary-btn:hover {
            background: #5a6268;
        }
        
        label {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        input[type="number"] {
            width: 80px;
            padding: 0.5rem;
            border: 2px solid #e0e0e0;
            border-radius: 5px;
            font-size: 1rem;
        }
        
        .output {
            background: #2d2d2d;
            color: #f8f8f2;
            padding: 1.5rem;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            min-height: 400px;
            overflow-y: auto;
            white-space: pre-wrap;
            word-break: break-word;
        }
        
        .examples {
            background: #f8f9fa;
            padding: 1rem;
            border-radius: 5px;
            margin-top: 1rem;
        }
        
        .example-btn {
            background: #e9ecef;
            color: #333;
            padding: 0.5rem 1rem;
            margin: 0.3rem;
            border: 2px solid #dee2e6;
            border-radius: 5px;
            font-size: 0.9rem;
        }
        
        .example-btn:hover {
            background: #dee2e6;
        }
        
        .info-box {
            background: #e7f3ff;
            padding: 1rem;
            border-radius: 5px;
            border-left: 4px solid #4a90e2;
            margin: 1rem 0;
        }
        
        .error {
            background: #ffe7e7;
            border-left-color: #dc3545;
            color: #721c24;
        }
        
        .success {
            background: #d4edda;
            border-left-color: #28a745;
            color: #155724;
        }
        
        footer {
            text-align: center;
            padding: 2rem;
            color: #6c757d;
            margin-top: 3rem;
        }
        
        footer a {
            color: #4a90e2;
            text-decoration: none;
        }
        
        @media (max-width: 968px) {
            .simulator-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <header>
        <h1>üåä cqs-rs Browser Simulator</h1>
        <p>Run quantum circuits right in your browser - no installation needed!</p>
        <div>
            <span class="badge">Browser-Based</span>
            <span class="badge">JavaScript</span>
            <span class="badge">Open Source</span>
        </div>
        <div class="header-buttons">
            <button class="header-btn" onclick="downloadFullDocs()">üì• Download Full Documentation</button>
            <a href="https://patternripple.com" class="header-btn">Visit PatternRipple.com</a>
        </div>
        <p style="margin-top: 1rem; font-size: 0.9rem; opacity: 0.9;">
            By <a href="https://patternripple.com" style="color: white; text-decoration: underline;">PatternRipple.com Labs</a> ‚Ä¢ Created by <a href="https://heylink.me/nickpanek/" style="color: white; text-decoration: underline;" target="_blank">Nick Panek</a>
        </p>
    </header>

    <div class="container">
        <div class="info-box">
            <strong>‚ú® Browser Demo Version!</strong> This is a simplified JavaScript demo of the full cqs-rs simulator (originally written in Rust). 
            It runs entirely in your browser with zero setup - perfect for quick experiments! 
            <br><br>
            <strong>Want the full-featured Rust version?</strong> Download the documentation above for complete installation instructions. 
            The Rust version includes advanced features like noise models, constraints, deterministic replay, and telemetry logging.
        </div>

        <div class="simulator-grid">
            <div class="panel">
                <h2>üìù Quantum Circuit Program</h2>
                <div class="examples">
                    <strong>Quick Examples:</strong><br>
                    <button class="example-btn" onclick="loadExample('bell')">Bell State</button>
                    <button class="example-btn" onclick="loadExample('superposition')">Superposition</button>
                    <button class="example-btn" onclick="loadExample('ghz')">GHZ State</button>
                    <button class="example-btn" onclick="loadExample('phase')">Phase Flip</button>
                </div>
                <textarea id="program" spellcheck="false">[
  {"op": "init", "n": 2},
  {"op": "h", "q": 0},
  {"op": "cnot", "ctrl": 0, "tgt": 1},
  {"op": "measure", "qubits": [0, 1]}
]</textarea>
                
                <div class="controls">
                    <button onclick="runSimulation()">‚ñ∂Ô∏è Run Simulation</button>
                    <button class="secondary-btn" onclick="clearProgram()">Clear</button>
                    <label>
                        Shots: <input type="number" id="shots" value="100" min="1" max="10000">
                    </label>
                </div>
            </div>

            <div class="panel">
                <h2>üìä Output</h2>
                <div id="output" class="output">Ready to run! Click "Run Simulation" to see results...</div>
            </div>
        </div>

        <div class="panel">
            <h2>üìñ How to Use</h2>
            <ol style="margin-left: 2rem; line-height: 2;">
                <li>Choose an example or write your own JSON circuit program</li>
                <li>Set the number of shots (how many times to run the circuit)</li>
                <li>Click "Run Simulation"</li>
                <li>See the measurement results in the output panel</li>
            </ol>
            <p style="margin-top: 1rem;"><strong>Available operations:</strong> init, h, x, y, z, rx, ry, rz, cnot, cz, measure</p>
            <p style="margin-top: 0.5rem;">For full documentation, click "Download Full Documentation" above or visit <a href="https://www.patternripple.com/cqs_rs_docs.html">the docs page</a></p>
        </div>
    </div>

    <footer>
        <p>Developed by <a href="https://patternripple.com">PatternRipple.com Labs</a> ‚Ä¢ Created by <a href="https://heylink.me/nickpanek/" target="_blank">Nick Panek</a></p>
        <p style="margin-top: 0.5rem;">Open source and free to use ‚Ä¢ No server required</p>
    </footer>

    <script>
        // Simple quantum simulator in JavaScript
        class QuantumState {
            constructor(n) {
                this.n = n;
                this.amplitudes = new Map();
                this.amplitudes.set(0, {re: 1, im: 0});
            }

            getAmplitude(state) {
                return this.amplitudes.get(state) || {re: 0, im: 0};
            }

            setAmplitude(state, amp) {
                if (Math.abs(amp.re) < 1e-10 && Math.abs(amp.im) < 1e-10) {
                    this.amplitudes.delete(state);
                } else {
                    this.amplitudes.set(state, amp);
                }
            }

            getProbability(state) {
                const amp = this.getAmplitude(state);
                return amp.re * amp.re + amp.im * amp.im;
            }

            normalize() {
                let sum = 0;
                for (const amp of this.amplitudes.values()) {
                    sum += amp.re * amp.re + amp.im * amp.im;
                }
                const norm = Math.sqrt(sum);
                if (norm > 0) {
                    for (const [state, amp] of this.amplitudes.entries()) {
                        this.amplitudes.set(state, {re: amp.re / norm, im: amp.im / norm});
                    }
                }
            }
        }

        function complexMul(a, b) {
            return {
                re: a.re * b.re - a.im * b.im,
                im: a.re * b.im + a.im * b.re
            };
        }

        function complexAdd(a, b) {
            return {re: a.re + b.re, im: a.im + b.im};
        }

        function applyH(state, q) {
            const newAmplitudes = new Map();
            const norm = 1 / Math.sqrt(2);
            
            for (const [idx, amp] of state.amplitudes.entries()) {
                const bit = (idx >> q) & 1;
                const flipped = idx ^ (1 << q);
                
                const contrib1 = {re: amp.re * norm, im: amp.im * norm};
                const contrib2 = bit === 0 
                    ? {re: amp.re * norm, im: amp.im * norm}
                    : {re: -amp.re * norm, im: -amp.im * norm};
                
                const curr1 = newAmplitudes.get(idx) || {re: 0, im: 0};
                const curr2 = newAmplitudes.get(flipped) || {re: 0, im: 0};
                
                newAmplitudes.set(idx, complexAdd(curr1, contrib1));
                newAmplitudes.set(flipped, complexAdd(curr2, contrib2));
            }
            
            state.amplitudes = newAmplitudes;
        }

        function applyX(state, q) {
            const newAmplitudes = new Map();
            for (const [idx, amp] of state.amplitudes.entries()) {
                const flipped = idx ^ (1 << q);
                newAmplitudes.set(flipped, amp);
            }
            state.amplitudes = newAmplitudes;
        }

        function applyY(state, q) {
            const newAmplitudes = new Map();
            for (const [idx, amp] of state.amplitudes.entries()) {
                const bit = (idx >> q) & 1;
                const flipped = idx ^ (1 << q);
                const newAmp = bit === 0 
                    ? {re: -amp.im, im: amp.re}
                    : {re: amp.im, im: -amp.re};
                newAmplitudes.set(flipped, newAmp);
            }
            state.amplitudes = newAmplitudes;
        }

        function applyZ(state, q) {
            for (const [idx, amp] of state.amplitudes.entries()) {
                const bit = (idx >> q) & 1;
                if (bit === 1) {
                    state.amplitudes.set(idx, {re: -amp.re, im: -amp.im});
                }
            }
        }

        function applyRZ(state, q, theta) {
            const phase0 = {re: Math.cos(-theta/2), im: Math.sin(-theta/2)};
            const phase1 = {re: Math.cos(theta/2), im: Math.sin(theta/2)};
            
            for (const [idx, amp] of state.amplitudes.entries()) {
                const bit = (idx >> q) & 1;
                const phase = bit === 0 ? phase0 : phase1;
                state.amplitudes.set(idx, complexMul(amp, phase));
            }
        }

        function applyCNOT(state, ctrl, tgt) {
            const newAmplitudes = new Map();
            for (const [idx, amp] of state.amplitudes.entries()) {
                const ctrlBit = (idx >> ctrl) & 1;
                const newIdx = ctrlBit === 1 ? idx ^ (1 << tgt) : idx;
                newAmplitudes.set(newIdx, amp);
            }
            state.amplitudes = newAmplitudes;
        }

        function applyCZ(state, ctrl, tgt) {
            for (const [idx, amp] of state.amplitudes.entries()) {
                const ctrlBit = (idx >> ctrl) & 1;
                const tgtBit = (idx >> tgt) & 1;
                if (ctrlBit === 1 && tgtBit === 1) {
                    state.amplitudes.set(idx, {re: -amp.re, im: -amp.im});
                }
            }
        }

        function measure(state, qubits) {
            const outcomes = 1 << qubits.length;
            const probs = new Array(outcomes).fill(0);
            
            for (const [idx, amp] of state.amplitudes.entries()) {
                let outcome = 0;
                for (let i = 0; i < qubits.length; i++) {
                    const bit = (idx >> qubits[i]) & 1;
                    outcome |= bit << i;
                }
                probs[outcome] += amp.re * amp.re + amp.im * amp.im;
            }
            
            const rand = Math.random();
            let cumProb = 0;
            for (let i = 0; i < outcomes; i++) {
                cumProb += probs[i];
                if (rand <= cumProb) {
                    return i;
                }
            }
            return outcomes - 1;
        }

        function runCircuit(program, shots) {
            const results = [];
            
            for (let shot = 0; shot < shots; shot++) {
                let state = null;
                
                for (const op of program) {
                    if (op.op === 'init') {
                        state = new QuantumState(op.n);
                    } else if (op.op === 'h') {
                        applyH(state, op.q);
                    } else if (op.op === 'x') {
                        applyX(state, op.q);
                    } else if (op.op === 'y') {
                        applyY(state, op.q);
                    } else if (op.op === 'z') {
                        applyZ(state, op.q);
                    } else if (op.op === 'rz') {
                        applyRZ(state, op.q, op.theta);
                    } else if (op.op === 'cnot') {
                        applyCNOT(state, op.ctrl, op.tgt);
                    } else if (op.op === 'cz') {
                        applyCZ(state, op.ctrl, op.tgt);
                    } else if (op.op === 'measure') {
                        const outcome = measure(state, op.qubits);
                        results.push(outcome);
                    }
                }
            }
            
            return results;
        }

        function runSimulation() {
            const programText = document.getElementById('program').value;
            const shots = parseInt(document.getElementById('shots').value);
            const output = document.getElementById('output');
            
            try {
                const program = JSON.parse(programText);
                output.textContent = 'Running simulation...\n\n';
                
                setTimeout(() => {
                    try {
                        const results = runCircuit(program, shots);
                        
                        // Count outcomes
                        const counts = {};
                        for (const result of results) {
                            const bitstring = result.toString(2).padStart(2, '0');
                            counts[bitstring] = (counts[bitstring] || 0) + 1;
                        }
                        
                        let outputText = `‚úÖ Simulation Complete!\n\n`;
                        outputText += `Shots: ${shots}\n`;
                        outputText += `Unique outcomes: ${Object.keys(counts).length}\n\n`;
                        outputText += `Results:\n`;
                        outputText += `${'='.repeat(40)}\n`;
                        
                        const sorted = Object.entries(counts).sort((a, b) => b[1] - a[1]);
                        for (const [bitstring, count] of sorted) {
                            const percent = (count / shots * 100).toFixed(1);
                            const bar = '‚ñà'.repeat(Math.floor(count / shots * 50));
                            outputText += `|${bitstring}‚ü©: ${count.toString().padStart(5)} (${percent}%) ${bar}\n`;
                        }
                        
                        output.textContent = outputText;
                    } catch (err) {
                        output.textContent = `‚ùå Error running simulation:\n${err.message}`;
                    }
                }, 10);
                
            } catch (err) {
                output.textContent = `‚ùå JSON Parse Error:\n${err.message}\n\nPlease check your JSON syntax.`;
            }
        }

        function clearProgram() {
            document.getElementById('program').value = '';
            document.getElementById('output').textContent = 'Ready to run!';
        }

        function loadExample(name) {
            const examples = {
                bell: `[
  {"op": "init", "n": 2},
  {"op": "h", "q": 0},
  {"op": "cnot", "ctrl": 0, "tgt": 1},
  {"op": "measure", "qubits": [0, 1]}
]`,
                superposition: `[
  {"op": "init", "n": 3},
  {"op": "h", "q": 0},
  {"op": "h", "q": 1},
  {"op": "h", "q": 2},
  {"op": "measure", "qubits": [0, 1, 2]}
]`,
                ghz: `[
  {"op": "init", "n": 3},
  {"op": "h", "q": 0},
  {"op": "cnot", "ctrl": 0, "tgt": 1},
  {"op": "cnot", "ctrl": 1, "tgt": 2},
  {"op": "measure", "qubits": [0, 1, 2]}
]`,
                phase: `[
  {"op": "init", "n": 1},
  {"op": "h", "q": 0},
  {"op": "z", "q": 0},
  {"op": "h", "q": 0},
  {"op": "measure", "qubits": [0]}
]`
            };
            
            document.getElementById('program').value = examples[name];
            document.getElementById('output').textContent = 'Program loaded! Click Run to simulate.';
        }

        function downloadFullDocs() {
            const docs = `cqs-rs Full Technical Documentation
Version 0.17.1
Developed by PatternRipple.com Labs
Created by Nick Panek (https://heylink.me/nickpanek/)

================================================================================
TABLE OF CONTENTS
================================================================================
1. Overview
2. Installation - Full Rust Version
3. Browser Demo vs Full Rust Version
4. Quick Start
5. JSON Program Operations
6. Mathematical Foundation
7. Advanced Features
8. Cross-Validation with Qiskit
9. Benchmarking
10. Testing
11. Source Code Structure

================================================================================
1. OVERVIEW
================================================================================

cqs-rs is a constraint- and replay-aware sparse quantum state simulator written
in Rust. It provides:

- Epsilon-sparse pruning with tracked dropped norm delta
- Constraint-aware execution: Hamming weight or parity
- Deterministic replay via event-indexed RNG using BLAKE3-keyed hashing
- JSONL trajectory logging with per-step telemetry

Key Features:
- Sparse state representation for memory efficiency
- Support for constraints (Hamming weight, parity)
- Deterministic simulation with seeded RNG
- Comprehensive gate set (H, X, Y, Z, RX, RY, RZ, CNOT, CZ)
- Noise models (dephasing, depolarizing, amplitude damping)
- Measurement and postselection
- Detailed telemetry logging

================================================================================
2. INSTALLATION - FULL RUST VERSION
================================================================================

The browser demo is JavaScript-only. For the full-featured Rust version with
advanced capabilities, follow these installation steps:

STEP 1: Install Rust
--------------------
If you don't have Rust installed:

**On macOS/Linux:**
  Open terminal and run:
  curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
  
  Follow the on-screen instructions. When complete, run:
  source $HOME/.cargo/env

**On Windows:**
  Download and run: https://rustup.rs/
  Follow the installer instructions.

**Verify Installation:**
  rustc --version
  cargo --version
  
  You should see version numbers printed.

STEP 2: Get the Source Code
----------------------------
You need the cqs-rs source code. Contact PatternRipple.com Labs or check:
  https://patternripple.com

The source should include:
  - Cargo.toml (package configuration)
  - src/ directory (Rust source code)
  - All the files mentioned in Section 11

STEP 3: Build the Project
--------------------------
Navigate to the cqs-rs directory in your terminal:
  cd /path/to/cqs-rs

Build the release version:
  cargo build --release

This may take a few minutes the first time as it downloads dependencies
and compiles everything with optimizations.

STEP 4: Verify Installation
----------------------------
The compiled binary will be at:
  target/release/cqs        (on macOS/Linux)
  target\\release\\cqs.exe    (on Windows)

Test it:
  ./target/release/cqs --help

You should see usage information.

STEP 5: (Optional) Add to PATH
-------------------------------
To use 'cqs' from anywhere:

**On macOS/Linux:**
  Add this line to ~/.bashrc or ~/.zshrc:
  export PATH="$PATH:/path/to/cqs-rs/target/release"
  
  Then reload:
  source ~/.bashrc  (or ~/.zshrc)

**On Windows:**
  Add the full path to target\\release to your system PATH environment variable.

STEP 6: Run Your First Simulation
----------------------------------
Create a test program:
  echo '[
    {"op": "init", "n": 2},
    {"op": "h", "q": 0},
    {"op": "cnot", "ctrl": 0, "tgt": 1},
    {"op": "measure", "qubits": [0, 1]}
  ]' > test.json

Run it:
  ./target/release/cqs run --program test.json --shots 100

You should see measurement results!

TROUBLESHOOTING
---------------
Problem: "cargo: command not found"
Solution: Rust isn't installed or not in PATH. Repeat Step 1.

Problem: Compilation errors
Solution: Make sure you have the latest Rust: rustup update

Problem: Missing dependencies on Linux
Solution: You may need build essentials:
  sudo apt-get install build-essential  (Ubuntu/Debian)
  sudo yum groupinstall "Development Tools"  (RHEL/CentOS)

For more help, visit: https://patternripple.com

================================================================================
3. BROWSER DEMO vs FULL RUST VERSION
================================================================================

BROWSER DEMO (JavaScript):
  ‚úì Runs instantly in your browser
  ‚úì No installation required
  ‚úì Basic gates: H, X, Y, Z, RZ, CNOT, CZ
  ‚úì Simple measurement
  ‚úó No noise models
  ‚úó No constraints
  ‚úó No deterministic replay
  ‚úó No telemetry logging
  ‚úó Limited to small circuits

FULL RUST VERSION:
  ‚úì All gates including RX, RY, generic rotations
  ‚úì Noise models (dephasing, depolarizing, amplitude damping)
  ‚úì Constraint modes (Hamming weight, parity)
  ‚úì Deterministic replay with BLAKE3 seeding
  ‚úì Detailed JSONL telemetry logging
  ‚úì Sparse state pruning (epsilon thresholds)
  ‚úì Postselection support
  ‚úì Command-line interface with full control
  ‚úì Optimized for larger circuits
  ‚úì Cross-validation with Qiskit
  ‚úì Built-in benchmarking tools
  
Recommendation: Use the browser demo for quick experiments and learning.
                Use the full Rust version for research, production, or 
                advanced features.

================================================================================
4. QUICK START
================================================================================

Minimal Example:

cat > program.json << 'JSON'
[
  {
    "op": "init",
    "n": 3,
    "eps2": 1e-12,
    "mode": "project",
    "constraint": {"kind": "parity", "even": true},
    "seed_hex": "000102030405060708090a0b0c0d0e0f000102030405060708090a0b0c0d0e0f"
  },
  {"op": "h", "q": 0},
  {"op": "rz", "q": 0, "theta": 1.234},
  {"op": "cnot", "ctrl": 0, "tgt": 1},
  {"op": "cz", "ctrl": 1, "tgt": 2},
  {"op": "measure", "qubits": [0, 1, 2]}
]
JSON

Run the program:
  ./target/release/cqs run --program program.json --shots 4 --log traj

Output logs will be at: traj-*.jsonl

================================================================================
5. JSON PROGRAM OPERATIONS
================================================================================

5.1 INITIALIZATION
------------------
Operation: init
Parameters:
  - n: Number of qubits (required)
  - eps2: Sparse pruning threshold (optional, default: 0.0)
  - mode: "invariant" or "project" (optional, default: "project")
  - constraint: Constraint specification (optional)
  - seed_hex: 64-character hex string for RNG seed (optional)

Constraint Types:
  - {"kind": "none"} - No constraints (default)
  - {"kind": "hamming", "k": 2} - Fixed Hamming weight k
  - {"kind": "parity", "even": true} - Even/odd parity

Example:
  {"op": "init", "n": 4, "eps2": 1e-10, "constraint": {"kind": "hamming", "k": 2}}

5.2 SINGLE-QUBIT GATES
----------------------
H Gate (Hadamard):
  {"op": "h", "q": 0}
  Creates superposition: |0‚ü© ‚Üí (|0‚ü© + |1‚ü©)/‚àö2

X Gate (Pauli-X / NOT):
  {"op": "x", "q": 0}
  Bit flip: |0‚ü© ‚Üî |1‚ü©

Y Gate (Pauli-Y):
  {"op": "y", "q": 0}
  Bit flip with phase: |0‚ü© ‚Üí i|1‚ü©, |1‚ü© ‚Üí -i|0‚ü©

Z Gate (Pauli-Z):
  {"op": "z", "q": 0}
  Phase flip: |1‚ü© ‚Üí -|1‚ü©

RX Gate (Rotation around X-axis):
  {"op": "rx", "q": 0, "theta": 1.57}
  Rotation by angle theta (in radians)

RY Gate (Rotation around Y-axis):
  {"op": "ry", "q": 0, "theta": 0.785}
  Rotation by angle theta (in radians)

RZ Gate (Rotation around Z-axis):
  {"op": "rz", "q": 0, "theta": 3.14}
  Rotation by angle theta (in radians)

Generic Rotation:
  {"op": "rot", "q": 0, "axis": "x", "theta": 1.57}
  Axis can be "x", "y", or "z"

5.3 TWO-QUBIT GATES
-------------------
CNOT Gate (Controlled-NOT):
  {"op": "cnot", "ctrl": 0, "tgt": 1}
  Flips target if control is |1‚ü©

CZ Gate (Controlled-Z):
  {"op": "cz", "ctrl": 0, "tgt": 1}
  Applies phase if both qubits are |1‚ü©

All-to-All CZ:
  {"op": "all2all_cz"}
  Applies CZ between all qubit pairs
  Optimized for fixed Hamming weight: global phase (-1)^{k(k-1)/2}

5.4 NOISE OPERATIONS
--------------------
Dephasing Noise:
  {"op": "noise", "kind": {"kind": "dephasing", "p": 0.01}, "q": 0}
  Applies Z gate with probability p

Depolarizing Noise:
  {"op": "noise", "kind": {"kind": "depolarizing", "p": 0.01}, "q": 0}
  Applies X, Y, or Z each with probability p/3

Amplitude Damping:
  {"op": "noise", "kind": {"kind": "amplitude_damping", "gamma": 0.05}, "q": 0}
  Models energy loss from |1‚ü© to |0‚ü©

5.5 MEASUREMENT AND POSTSELECTION
---------------------------------
Measurement:
  {"op": "measure", "qubits": [0, 1, 2]}
  Measures specified qubits, collapses state

Postselection:
  {"op": "postselect", "qubits": [0, 1], "bits": "01"}
  Projects onto specified measurement outcome

================================================================================
6. MATHEMATICAL FOUNDATION
================================================================================

6.1 SPARSE PRUNING
------------------
- Amplitudes with probability weight ‚â§ eps2 are dropped
- Dropped probability accumulates in delta
- delta ‚â• P_drop + P_proj
  where P_drop = pruned mass, P_proj = projected mass

6.2 TOTAL VARIATION BOUND
--------------------------
For measurement distributions M(actual) vs M(ideal):
  TV(M(actual), M(ideal)) ‚â§ sqrt(delta)

The TV upper bound is accessible as: tv_upper_bound = sqrt(delta)

Trace distance increases are bounded by sqrt(discarded probability)

6.3 CONSTRAINT EXECUTION MODES
-------------------------------
InvariantOnly:
  - Gate must preserve allowed index set
  - Error if gate would violate constraint
  - No projection or delta growth

ProjectWithBounds:
  - Apply gate
  - Project out forbidden basis states
  - Add their mass to delta
  - Renormalize
  - Exposes tv_upper_bound

6.4 GATE INVARIANCE
-------------------
Diagonal gates preserve any constraint:
  - Z, RZ, CZ, ALL2ALL_CZ

Mixing gates only safe with no constraint:
  - H, X, Y, RX, RY, CNOT

6.5 NOISE CHANNELS (Trajectory Unraveling)
-------------------------------------------
Dephasing (parameter p):
  - Apply Z with probability p
  - Identity with probability 1-p

Depolarizing (parameter p):
  - Identity with probability 1-p
  - X, Y, or Z each with probability p/3

Amplitude Damping (parameter gamma):
  - Jump operator: sqrt(gamma) * |0‚ü©‚ü®1|
  - No-jump update with (1-gamma) scaling
  - Deterministic based on RNG

6.6 DETERMINISTIC REPLAY
-------------------------
EventRng uses keyed BLAKE3 hash over:
  - kind: Event type string
  - step: Current step counter
  - shot: Shot number
  - qubits: Qubit indices array
  - extra: Extra parameter

This ensures reproducible randomness across runs with same seed.

6.7 ALL-TO-ALL CZ OPTIMIZATION
-------------------------------
For fixed Hamming weight k:
  - Global phase: (-1)^{k(k-1)/2}
  - No need to iterate over all pairs
  - Significant speedup for large systems

================================================================================
7. ADVANCED FEATURES
================================================================================

7.1 TELEMETRY LOGGING
---------------------
When --log flag is used, creates JSONL files with per-step data:
  - event: Operation type
  - step, shot: Counters
  - norm_pre, norm_post: State norm before/after
  - amps_len_pre, amps_len_post: Number of non-zero amplitudes
  - delta_inc: Increase in delta this step
  - delta: Cumulative delta
  - tv_upper_bound: Current TV bound

Use for:
  - Debugging state evolution
  - Auditing bound growth
  - Memory profiling
  - Performance analysis

7.2 CONSTRAINT MODES IN DETAIL
-------------------------------
InvariantOnly Mode:
  - Best for: Studying constraint-preserving circuits
  - No overhead from projection
  - Stricter gate restrictions
  - Errors immediately if constraint violated

ProjectWithBounds Mode:
  - Best for: General simulations with constraint awareness
  - Automatic projection and renormalization
  - Tracks approximation quality via tv_upper_bound
  - More flexible gate usage

7.3 SPARSE THRESHOLD TUNING
----------------------------
eps2 = 1e-12: Very accurate, higher memory
eps2 = 1e-8:  Balanced accuracy and memory
eps2 = 1e-6:  Fast, lower memory, some error

Monitor tv_upper_bound to assess quality/error tradeoff.

7.4 SEED FORMAT
---------------
Seed must be exactly 64 hexadecimal characters (32 bytes).
Example: "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"

Different seeds produce different but deterministic outcomes.
Same seed always produces identical results.

================================================================================
8. CROSS-VALIDATION WITH QISKIT
================================================================================

For circuits with n ‚â§ 4 qubits, validate against IBM Qiskit:

  python3 scripts/crossval_qiskit.py program.json

Important Note:
- Qiskit returns big-endian classical bits
- The script reverses bit order to match cqs-rs little-endian format
- Example: Qiskit "10" becomes cqs-rs "01"

Unsupported in cross-validation:
- Postselection operations
- Noise operations

================================================================================
9. BENCHMARKING
================================================================================

Run microbenchmarks:
  cargo run --release --bin cqs_bench

Customize with environment variables:
  CQS_BENCH_N=18           # Number of qubits
  CQS_BENCH_SHOTS=100      # Number of shots
  CQS_BENCH_EPS2=1e-12     # Sparse threshold
  CQS_BENCH_GAMMA=0.05     # Noise parameter

Example:
  CQS_BENCH_N=20 CQS_BENCH_SHOTS=50 cargo run --release --bin cqs_bench

Benchmark suites:
- h-cz-chain: Hadamard + CZ chain pattern
- entangle-stress: Full entanglement generation
- noise-sweep: Noise application performance

================================================================================
10. TESTING
================================================================================

Run all tests:
  cargo test

Test suites:
- tests/basic.rs: Core functionality tests
  - Reproducible measurements
  - TV bound tracking
  - Gate constraint checks
  
- tests/integration.rs: Integration tests
  - Empty measurement handling
  - Sparse pruning behavior
  - Noise parameter validation
  - Postselection edge cases

- tests/proptests.rs: Property-based tests
  - Gate identities (H¬≤, CZ¬≤, etc.)
  - Rotation inverse properties
  - CNOT squared identity
  - State fidelity preservation

================================================================================
11. SOURCE CODE STRUCTURE
================================================================================

Cargo.toml:
  - Package metadata and dependencies
  - Binary targets: cqs, cqs_bench

src/lib.rs:
  - Main State struct
  - Public API for all operations
  - Mode and error definitions

src/rng.rs:
  - EventRng: Deterministic BLAKE3-based RNG
  - Methods: u128_for_event, u01_for_event, choose_index

src/constraint.rs:
  - Constraint enum (None, HammingWeight, Parity)
  - allowed_index: Check if basis state satisfies constraint
  - check_gate_invariance: Gate compatibility with constraints

src/gates.rs:
  - Gate implementations
  - Functions: apply_h_on, apply_x_on, etc.
  - Optimized all2all_cz

src/noise.rs:
  - Noise enum (Dephasing, Depolarizing, AmplitudeDamping)
  - Trajectory unraveling implementations

src/measure.rs:
  - measure_and_collapse: Quantum measurement
  - postselect_and_collapse: Postselection
  - Measurement logging

src/log.rs:
  - TrajLogger: JSONL trajectory logging
  - Buffered file writing

src/bin/cqs.rs:
  - CLI interface using clap
  - JSON program parsing
  - Main execution loop

src/bin/cqs_bench.rs:
  - Microbenchmark suite
  - Configurable via environment variables

================================================================================
IMPLEMENTATION NOTES
================================================================================

1. CZ and CNOT with c == t are no-ops by design
2. Bit ordering is little-endian (bit 0 is LSB)
3. Complex amplitudes use num-complex crate
4. State uses IndexMap for sparse storage
5. scratch_map pre-allocated for gate operations
6. All gates support qubit index validation
7. Telemetry overhead is minimal when logging disabled

================================================================================
PERFORMANCE TIPS
================================================================================

1. Use appropriate eps2 for your accuracy needs
2. Enable logging only when needed (adds I/O overhead)
3. For large systems, consider Hamming weight constraints
4. Use all2all_cz optimization when possible
5. Profile with cargo run --release --bin cqs_bench

================================================================================
ERROR HANDLING
================================================================================

SimError enum covers:
- GateBreaksConstraint: Gate violates invariant mode constraint
- PostselectLen: Postselection bit string length mismatch
- PostselectImpossible: Postselection on zero-probability outcome
- BadQubit: Qubit index out of bounds
- MissingInit: Operations before init
- InvalidNoiseParameter: Noise parameter out of [0,1] range
- BadSeed: Invalid RNG seed format

================================================================================
LICENSE & CREDITS
================================================================================

Version: 0.17.1
License: Open Source (Previously Proprietary, now released as open source)
Developed by: PatternRipple.com Labs
Created by: Nick Panek (https://heylink.me/nickpanek/)
Website: https://patternripple.com

Keywords: quantum, simulator, replay, sparse

This software is provided as-is, without warranty of any kind.

================================================================================
CONTACT & SUPPORT
================================================================================

For questions, issues, or contributions:
Visit: https://patternripple.com

For the latest version and updates:
Check: https://www.patternripple.com/cqs_rs_docs.html

================================================================================
END OF DOCUMENTATION
================================================================================`;

            const blob = new Blob([docs], { type: 'text/plain' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'cqs-rs-documentation.txt';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);
        }
    </script>
</body>
</html>
