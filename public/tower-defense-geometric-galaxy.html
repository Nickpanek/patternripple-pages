<!DOCTYPE html>
<html lang="en">
<head>
Â  Â  <meta charset="UTF-8">
Â  Â  <meta name="viewport" content="width=device-width, initial-scale=1.0">
Â  Â  <title>Geometric Galaxy Tower Defense - Pattern Ripple</title>
Â  Â  <style>
Â  Â  Â  Â  * {
Â  Â  Â  Â  Â  Â  margin: 0;
Â  Â  Â  Â  Â  Â  padding: 0;
Â  Â  Â  Â  Â  Â  box-sizing: border-box;
Â  Â  Â  Â  }

Â  Â  Â  Â  body {
Â  Â  Â  Â  Â  Â  font-family: 'Courier New', monospace;
Â  Â  Â  Â  Â  Â  overflow: hidden;
Â  Â  Â  Â  Â  Â  background: #000;
Â  Â  Â  Â  }

Â  Â  Â  Â  #gameCanvas {
Â  Â  Â  Â  Â  Â  display: block;
Â  Â  Â  Â  Â  Â  width: 100%;
Â  Â  Â  Â  Â  Â  height: 100vh;
Â  Â  Â  Â  }

Â  Â  Â  Â  #ui {
Â  Â  Â  Â  Â  Â  position: absolute;
Â  Â  Â  Â  Â  Â  top: 20px;
Â  Â  Â  Â  Â  Â  left: 20px;
Â  Â  Â  Â  Â  Â  color: #00ffff;
Â  Â  Â  Â  Â  Â  font-size: 18px;
Â  Â  Â  Â  Â  Â  background: rgba(0, 0, 0, 0.85);
Â  Â  Â  Â  Â  Â  padding: 20px;
Â  Â  Â  Â  Â  Â  border-radius: 5px;
Â  Â  Â  Â  Â  Â  border: 2px solid #00ffff;
Â  Â  Â  Â  Â  Â  z-index: 100;
Â  Â  Â  Â  Â  Â  font-weight: bold;
Â  Â  Â  Â  Â  Â  text-shadow: 0 0 10px #00ffff;
Â  Â  Â  Â  }

Â  Â  Â  Â  #ui h2 {
Â  Â  Â  Â  Â  Â  margin-bottom: 10px;
Â  Â  Â  Â  Â  Â  color: #ff3333;
Â  Â  Â  Â  Â  Â  text-shadow: 0 0 15px #ff3333;
Â  Â  Â  Â  }

Â  Â  Â  Â  #ui p {
Â  Â  Â  Â  Â  Â  margin: 5px 0;
Â  Â  Â  Â  }

Â  Â  Â  Â  #upgradePanel {
Â  Â  Â  Â  Â  Â  position: absolute;
Â  Â  Â  Â  Â  Â  top: 50%;
Â  Â  Â  Â  Â  Â  left: 50%;
Â  Â  Â  Â  Â  Â  transform: translate(-50%, -50%);
Â  Â  Â  Â  Â  Â  background: rgba(0, 0, 0, 0.95);
Â  Â  Â  Â  Â  Â  padding: 30px;
Â  Â  Â  Â  Â  Â  border-radius: 10px;
Â  Â  Â  Â  Â  Â  border: 3px solid #00ffff;
Â  Â  Â  Â  Â  Â  color: #00ffff;
Â  Â  Â  Â  Â  Â  display: none;
Â  Â  Â  Â  Â  Â  z-index: 200;
Â  Â  Â  Â  Â  Â  min-width: 400px;
Â  Â  Â  Â  Â  Â  max-width: 500px;
Â  Â  Â  Â  Â  Â  text-shadow: 0 0 5px #00ffff;
Â  Â  Â  Â  }

Â  Â  Â  Â  #upgradePanel h3 {
Â  Â  Â  Â  Â  Â  margin-bottom: 20px;
Â  Â  Â  Â  Â  Â  color: #ff3333;
Â  Â  Â  Â  Â  Â  text-align: center;
Â  Â  Â  Â  Â  Â  font-size: 24px;
Â  Â  Â  Â  Â  Â  text-shadow: 0 0 15px #ff3333;
Â  Â  Â  Â  }

Â  Â  Â  Â  #upgradePanel .specialization {
Â  Â  Â  Â  Â  Â  margin: 20px 0;
Â  Â  Â  Â  Â  Â  padding: 15px;
Â  Â  Â  Â  Â  Â  background: rgba(255, 255, 255, 0.05);
Â  Â  Â  Â  Â  Â  border-radius: 8px;
Â  Â  Â  Â  Â  Â  text-align: center;
Â  Â  Â  Â  }

Â  Â  Â  Â  #upgradePanel .specialization-label {
Â  Â  Â  Â  Â  Â  font-size: 18px;
Â  Â  Â  Â  Â  Â  color: #ff3333;
Â  Â  Â  Â  Â  Â  font-weight: bold;
Â  Â  Â  Â  Â  Â  margin-bottom: 10px;
Â  Â  Â  Â  Â  Â  text-shadow: 0 0 10px #ff3333;
Â  Â  Â  Â  }

Â  Â  Â  Â  #upgradePanel .stat {
Â  Â  Â  Â  Â  Â  margin: 10px 0;
Â  Â  Â  Â  Â  Â  display: flex;
Â  Â  Â  Â  Â  Â  justify-content: space-between;
Â  Â  Â  Â  Â  Â  font-size: 16px;
Â  Â  Â  Â  }

Â  Â  Â  Â  #upgradePanel .upgrade-options {
Â  Â  Â  Â  Â  Â  display: grid;
Â  Â  Â  Â  Â  Â  grid-template-columns: 1fr 1fr;
Â  Â  Â  Â  Â  Â  gap: 10px;
Â  Â  Â  Â  Â  Â  margin-top: 20px;
Â  Â  Â  Â  }

Â  Â  Â  Â  #upgradePanel .upgrade-option {
Â  Â  Â  Â  Â  Â  padding: 15px;
Â  Â  Â  Â  Â  Â  background: rgba(255, 255, 255, 0.05);
Â  Â  Â  Â  Â  Â  border: 2px solid #00ffff;
Â  Â  Â  Â  Â  Â  border-radius: 8px;
Â  Â  Â  Â  Â  Â  cursor: pointer;
Â  Â  Â  Â  Â  Â  transition: all 0.3s;
Â  Â  Â  Â  Â  Â  text-align: center;
Â  Â  Â  Â  }

Â  Â  Â  Â  #upgradePanel .upgrade-option:hover {
Â  Â  Â  Â  Â  Â  background: rgba(0, 255, 255, 0.2);
Â  Â  Â  Â  Â  Â  box-shadow: 0 0 20px #00ffff;
Â  Â  Â  Â  Â  Â  transform: scale(1.05);
Â  Â  Â  Â  }

Â  Â  Â  Â  #upgradePanel .upgrade-option.selected {
Â  Â  Â  Â  Â  Â  background: rgba(0, 255, 255, 0.3);
Â  Â  Â  Â  Â  Â  border-color: #00ffff;
Â  Â  Â  Â  }

Â  Â  Â  Â  #upgradePanel .upgrade-option h4 {
Â  Â  Â  Â  Â  Â  margin-bottom: 8px;
Â  Â  Â  Â  Â  Â  color: #00ffff;
Â  Â  Â  Â  Â  Â  font-size: 14px;
Â  Â  Â  Â  }

Â  Â  Â  Â  #upgradePanel .upgrade-option p {
Â  Â  Â  Â  Â  Â  font-size: 11px;
Â  Â  Â  Â  Â  Â  color: #aaa;
Â  Â  Â  Â  Â  Â  margin: 5px 0;
Â  Â  Â  Â  }

Â  Â  Â  Â  #upgradePanel .upgrade-option .cost {
Â  Â  Â  Â  Â  Â  color: #ff3333;
Â  Â  Â  Â  Â  Â  font-weight: bold;
Â  Â  Â  Â  Â  Â  margin-top: 8px;
Â  Â  Â  Â  Â  Â  text-shadow: 0 0 5px #ff3333;
Â  Â  Â  Â  }

Â  Â  Â  Â  #upgradePanel button {
Â  Â  Â  Â  Â  Â  width: 100%;
Â  Â  Â  Â  Â  Â  padding: 15px;
Â  Â  Â  Â  Â  Â  margin-top: 15px;
Â  Â  Â  Â  Â  Â  border: 2px solid #00ffff;
Â  Â  Â  Â  Â  Â  border-radius: 5px;
Â  Â  Â  Â  Â  Â  font-size: 16px;
Â  Â  Â  Â  Â  Â  cursor: pointer;
Â  Â  Â  Â  Â  Â  font-weight: bold;
Â  Â  Â  Â  Â  Â  font-family: 'Courier New', monospace;
Â  Â  Â  Â  Â  Â  transition: all 0.3s;
Â  Â  Â  Â  Â  Â  background: rgba(0, 255, 255, 0.1);
Â  Â  Â  Â  Â  Â  color: #00ffff;
Â  Â  Â  Â  Â  Â  text-shadow: 0 0 5px #00ffff;
Â  Â  Â  Â  }

Â  Â  Â  Â  #upgradePanel button:hover {
Â  Â  Â  Â  Â  Â  background: rgba(0, 255, 255, 0.3);
Â  Â  Â  Â  Â  Â  box-shadow: 0 0 20px #00ffff;
Â  Â  Â  Â  Â  Â  transform: scale(1.05);
Â  Â  Â  Â  }

Â  Â  Â  Â  #upgradePanel button:disabled {
Â  Â  Â  Â  Â  Â  background: rgba(100, 100, 100, 0.3);
Â  Â  Â  Â  Â  Â  border-color: #666;
Â  Â  Â  Â  Â  Â  color: #666;
Â  Â  Â  Â  Â  Â  cursor: not-allowed;
Â  Â  Â  Â  Â  Â  transform: none;
Â  Â  Â  Â  Â  Â  box-shadow: none;
Â  Â  Â  Â  Â  Â  text-shadow: none;
Â  Â  Â  Â  }

Â  Â  Â  Â  #closeBtn {
Â  Â  Â  Â  Â  Â  background: rgba(255, 51, 51, 0.1);
Â  Â  Â  Â  Â  Â  border-color: #ff3333;
Â  Â  Â  Â  Â  Â  color: #ff3333;
Â  Â  Â  Â  Â  Â  text-shadow: 0 0 5px #ff3333;
Â  Â  Â  Â  }

Â  Â  Â  Â  #closeBtn:hover {
Â  Â  Â  Â  Â  Â  background: rgba(255, 51, 51, 0.3);
Â  Â  Â  Â  Â  Â  box-shadow: 0 0 20px #ff3333;
Â  Â  Â  Â  }

Â  Â  Â  Â  #controls {
Â  Â  Â  Â  Â  Â  position: absolute;
Â  Â  Â  Â  Â  Â  bottom: 20px;
Â  Â  Â  Â  Â  Â  left: 50%;
Â  Â  Â  Â  Â  Â  transform: translateX(-50%);
Â  Â  Â  Â  Â  Â  background: rgba(0, 0, 0, 0.85);
Â  Â  Â  Â  Â  Â  padding: 15px 25px;
Â  Â  Â  Â  Â  Â  border-radius: 5px;
Â  Â  Â  Â  Â  Â  border: 2px solid #00ffff;
Â  Â  Â  Â  Â  Â  color: #00ffff;
Â  Â  Â  Â  Â  Â  text-align: center;
Â  Â  Â  Â  Â  Â  display: flex;
Â  Â  Â  Â  Â  Â  gap: 10px;
Â  Â  Â  Â  Â  Â  align-items: center;
Â  Â  Â  Â  }

Â  Â  Â  Â  #controls button {
Â  Â  Â  Â  Â  Â  background: rgba(0, 255, 255, 0.2);
Â  Â  Â  Â  Â  Â  color: #00ffff;
Â  Â  Â  Â  Â  Â  border: 2px solid #00ffff;
Â  Â  Â  Â  Â  Â  padding: 10px 20px;
Â  Â  Â  Â  Â  Â  border-radius: 5px;
Â  Â  Â  Â  Â  Â  font-size: 16px;
Â  Â  Â  Â  Â  Â  font-weight: bold;
Â  Â  Â  Â  Â  Â  font-family: 'Courier New', monospace;
Â  Â  Â  Â  Â  Â  cursor: pointer;
Â  Â  Â  Â  Â  Â  transition: all 0.3s;
Â  Â  Â  Â  Â  Â  text-shadow: 0 0 5px #00ffff;
Â  Â  Â  Â  }

Â  Â  Â  Â  #controls button:hover {
Â  Â  Â  Â  Â  Â  background: rgba(0, 255, 255, 0.4);
Â  Â  Â  Â  Â  Â  box-shadow: 0 0 20px #00ffff;
Â  Â  Â  Â  Â  Â  transform: scale(1.05);
Â  Â  Â  Â  }

Â  Â  Â  Â  #controls button:disabled {
Â  Â  Â  Â  Â  Â  background: rgba(100, 100, 100, 0.2);
Â  Â  Â  Â  Â  Â  border-color: #666;
Â  Â  Â  Â  Â  Â  color: #666;
Â  Â  Â  Â  Â  Â  cursor: not-allowed;
Â  Â  Â  Â  Â  Â  transform: none;
Â  Â  Â  Â  Â  Â  box-shadow: none;
Â  Â  Â  Â  Â  Â  text-shadow: none;
Â  Â  Â  Â  }

Â  Â  Â  Â  .info {
Â  Â  Â  Â  Â  Â  font-size: 12px;
Â  Â  Â  Â  Â  Â  color: #888;
Â  Â  Â  Â  Â  Â  margin-top: 10px;
Â  Â  Â  Â  }
Â  Â  </style>
</head>
<body>
Â  Â  <canvas id="gameCanvas"></canvas>

Â  Â  <div id="ui">
Â  Â  Â  Â  <h2>âš¡ GEOMETRIC GALAXY TD âš¡</h2>
Â  Â  Â  Â  <p>ğŸ’° Gold: <span id="gold">500</span></p>
Â  Â  Â  Â  <p>â¤ï¸ Lives: <span id="lives">20</span></p>
Â  Â  Â  Â  <p>ğŸŒŠ Wave: <span id="wave">0</span></p>
Â  Â  Â  Â  <p class="info">
Â  Â  Â  Â  Â  Â  Click tiles to build towers (100g)<br>
Â  Â  Â  Â  Â  Â  Click towers to upgrade
Â  Â  Â  Â  </p>
Â  Â  </div>

Â  Â  <div id="upgradePanel">
Â  Â  Â  Â  <h3>âš¡ TOWER UPGRADE âš¡</h3>
Â  Â  Â  Â  <div class="specialization" id="specializationInfo">
Â  Â  Â  Â  Â  Â  <div class="specialization-label" id="towerSpecialization">Basic Tower</div>
Â  Â  Â  Â  </div>
Â  Â  Â  Â  <div class="stat">
Â  Â  Â  Â  Â  Â  <span>Level:</span>
Â  Â  Â  Â  Â  Â  <span id="towerLevel">1</span>
Â  Â  Â  Â  </div>
Â  Â  Â  Â  <div class="stat">
Â  Â  Â  Â  Â  Â  <span>Range:</span>
Â  Â  Â  Â  Â  Â  <span id="towerRange">3.0</span>
Â  Â  Â  Â  </div>
Â  Â  Â  Â  <div class="stat">
Â  Â  Â  Â  Â  Â  <span>Fire Rate:</span>
Â  Â  Â  Â  Â  Â  <span id="towerFireRate">1.0/s</span>
Â  Â  Â  Â  </div>
Â  Â  Â  Â  <div class="stat">
Â  Â  Â  Â  Â  Â  <span>Damage:</span>
Â  Â  Â  Â  Â  Â  <span id="towerDamage">1</span>
Â  Â  Â  Â  </div>
Â  Â  Â  Â  <div id="upgradeTreeSection" style="display: none;">
Â  Â  Â  Â  Â  Â  <h4 style="color: #ff3333; margin-top: 20px; text-align: center; text-shadow: 0 0 10px #ff3333;">Choose Specialization</h4>
Â  Â  Â  Â  Â  Â  <div class="upgrade-options">
Â  Â  Â  Â  Â  Â  Â  Â  <div class="upgrade-option" data-type="rapidfire">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <h4>ğŸ”¥ Rapid Fire</h4>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <p>High fire rate</p>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <p>Lower damage</p>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <div class="cost">100g</div>
Â  Â  Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  Â  Â  <div class="upgrade-option" data-type="sniper">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <h4>ğŸ¯ Sniper</h4>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <p>Long range</p>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <p>High damage</p>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <div class="cost">100g</div>
Â  Â  Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  Â  Â  <div class="upgrade-option" data-type="frost">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <h4>â„ï¸ Frost</h4>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <p>Slows enemies</p>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <p>Moderate damage</p>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <div class="cost">100g</div>
Â  Â  Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  Â  Â  <div class="upgrade-option" data-type="splash">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <h4>ğŸ’¥ Splash</h4>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <p>Area damage</p>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <p>Hits multiple</p>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <div class="cost">100g</div>
Â  Â  Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  Â  Â  <div class="upgrade-option" data-type="poison">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <h4>â˜ ï¸ Poison</h4>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <p>Damage over time</p>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <p>Stacking effect</p>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <div class="cost">100g</div>
Â  Â  Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  </div>
Â  Â  Â  Â  <div id="upgradeStandardSection">
Â  Â  Â  Â  Â  Â  <button id="upgradeBtn">â¬†ï¸ UPGRADE (150g)</button>
Â  Â  Â  Â  </div>
Â  Â  Â  Â  <button id="closeBtn">âœ–ï¸ CLOSE</button>
Â  Â  </div>

Â  Â  <div id="confirmPanel" style="display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0, 0, 0, 0.95); padding: 30px; border-radius: 10px; border: 3px solid #00ffff; color: #00ffff; z-index: 200; min-width: 300px; text-shadow: 0 0 5px #00ffff;">
Â  Â  Â  Â  <h3 style="margin-bottom: 20px; color: #ff3333; text-align: center; text-shadow: 0 0 15px #ff3333;">Build Tower?</h3>
Â  Â  Â  Â  <p style="margin: 15px 0; text-align: center; font-size: 16px;">Cost: <span style="color: #ff3333; font-weight: bold; text-shadow: 0 0 5px #ff3333;">100 Gold</span></p>
Â  Â  Â  Â  <p style="font-size: 14px; color: #888; text-align: center; margin-bottom: 20px;">Place a tower on this tile?</p>
Â  Â  Â  Â  <div style="display: flex; gap: 10px;">
Â  Â  Â  Â  Â  Â  <button id="confirmBuildBtn" style="flex: 1; padding: 12px; border: 2px solid #00ffff; border-radius: 5px; font-size: 16px; cursor: pointer; font-weight: bold; font-family: 'Courier New', monospace; transition: all 0.3s; background: rgba(0, 255, 255, 0.1); color: #00ffff; text-shadow: 0 0 5px #00ffff;">BUILD</button>
Â  Â  Â  Â  Â  Â  <button id="cancelBuildBtn" style="flex: 1; padding: 12px; border: 2px solid #ff3333; border-radius: 5px; font-size: 16px; cursor: pointer; font-weight: bold; font-family: 'Courier New', monospace; transition: all 0.3s; background: rgba(255, 51, 51, 0.1); color: #ff3333; text-shadow: 0 0 5px #ff3333;">CANCEL</button>
Â  Â  Â  Â  </div>
Â  Â  </div>

Â  Â  <div id="controls">
Â  Â  Â  Â  <button id="waveBtn">â–¶ï¸ START WAVE</button>
Â  Â  </div>

Â  Â  <script type="importmap">
Â  Â  {
Â  Â  Â  Â  "imports": {
Â  Â  Â  Â  Â  Â  "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
Â  Â  Â  Â  Â  Â  "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
Â  Â  Â  Â  }
Â  Â  }
Â  Â  </script>

Â  Â  <script type="module">
Â  Â  Â  Â  import * as THREE from 'three';
Â  Â  Â  Â  import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
Â  Â  Â  Â  import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
Â  Â  Â  Â  import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

Â  Â  Â  Â  // ============================================
Â  Â  Â  Â  // GAME CONFIGURATION
Â  Â  Â  Â  // ============================================
Â  Â  Â  Â  const CONFIG = {
Â  Â  Â  Â  Â  Â  GRID_SIZE: 10,
Â  Â  Â  Â  Â  Â  TILE_SIZE: 1,
Â  Â  Â  Â  Â  Â  TOWER_COST: 100,
Â  Â  Â  Â  Â  Â  INITIAL_GOLD: 500,
Â  Â  Â  Â  Â  Â  INITIAL_LIVES: 20,
Â  Â  Â  Â  Â  Â  ELEVATION_HEIGHT: 0.5
Â  Â  Â  Â  };

Â  Â  Â  Â  // ============================================
Â  Â  Â  Â  // PATH DEFINITION - Winding glass path
Â  Â  Â  Â  // ============================================
Â  Â  Â  Â  const PATH = [
Â  Â  Â  Â  Â  Â  {x: 0, z: 1}, {x: 1, z: 1}, {x: 2, z: 1}, {x: 3, z: 1},
Â  Â  Â  Â  Â  Â  {x: 3, z: 2}, {x: 3, z: 3}, {x: 3, z: 4},
Â  Â  Â  Â  Â  Â  {x: 2, z: 4}, {x: 1, z: 4},
Â  Â  Â  Â  Â  Â  {x: 1, z: 5}, {x: 1, z: 6}, {x: 1, z: 7},
Â  Â  Â  Â  Â  Â  {x: 2, z: 7}, {x: 3, z: 7}, {x: 4, z: 7}, {x: 5, z: 7},
Â  Â  Â  Â  Â  Â  {x: 5, z: 6}, {x: 5, z: 5},
Â  Â  Â  Â  Â  Â  {x: 6, z: 5}, {x: 7, z: 5}, {x: 8, z: 5},
Â  Â  Â  Â  Â  Â  {x: 8, z: 6}, {x: 8, z: 7}, {x: 8, z: 8},
Â  Â  Â  Â  Â  Â  {x: 9, z: 8}
Â  Â  Â  Â  ];

Â  Â  Â  Â  // ============================================
Â  Â  Â  Â  // PROCEDURAL GLITCH ENEMY CLASS
Â  Â  Â  Â  // ============================================
Â  Â  Â  Â  class Enemy {
Â  Â  Â  Â  Â  Â  constructor(scene, path, wave) {
Â  Â  Â  Â  Â  Â  Â  Â  this.scene = scene;
Â  Â  Â  Â  Â  Â  Â  Â  this.path = path;
Â  Â  Â  Â  Â  Â  Â  Â  this.pathIndex = 0;
Â  Â  Â  Â  Â  Â  Â  Â  this.wave = wave;

Â  Â  Â  Â  Â  Â  Â  Â  // Match original game's difficulty
Â  Â  Â  Â  Â  Â  Â  Â  if (wave === 1) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.health = 2;
Â  Â  Â  Â  Â  Â  Â  Â  } else if (wave === 2) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.health = 3;
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.health = 3 + wave * 1.5;
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  this.maxHealth = this.health;
Â  Â  Â  Â  Â  Â  Â  Â  this.baseSpeed = 0.012 + (wave * 0.0015);
Â  Â  Â  Â  Â  Â  Â  Â  this.speed = this.baseSpeed;
Â  Â  Â  Â  Â  Â  Â  Â  this.reward = 3 + wave;
Â  Â  Â  Â  Â  Â  Â  Â  this.alive = true;
Â  Â  Â  Â  Â  Â  Â  Â  this.slowUntil = 0;
Â  Â  Â  Â  Â  Â  Â  Â  this.poisonStacks = [];

Â  Â  Â  Â  Â  Â  Â  Â  // Create Glitch Enemy with jagged shards
Â  Â  Â  Â  Â  Â  Â  Â  this.createGlitchMesh();

Â  Â  Â  Â  Â  Â  Â  Â  // Start at first path position
Â  Â  Â  Â  Â  Â  Â  Â  const startPos = this.path[0];
Â  Â  Â  Â  Â  Â  Â  Â  this.mesh.position.set(
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  startPos.x - CONFIG.GRID_SIZE/2 + 0.5,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  0.4,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  startPos.z - CONFIG.GRID_SIZE/2 + 0.5
Â  Â  Â  Â  Â  Â  Â  Â  );

Â  Â  Â  Â  Â  Â  Â  Â  this.scene.add(this.mesh);
Â  Â  Â  Â  Â  Â  Â  Â  this.rotationSpeed = 0.02;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  createGlitchMesh() {
Â  Â  Â  Â  Â  Â  Â  Â  // Create IcosahedronGeometry with vertex jittering
Â  Â  Â  Â  Â  Â  Â  Â  const geometry = new THREE.IcosahedronGeometry(0.35, 1);
Â  Â  Â  Â  Â  Â  Â  Â  const positions = geometry.attributes.position;

Â  Â  Â  Â  Â  Â  Â  Â  // Jitter vertices to create jagged glitch effect
Â  Â  Â  Â  Â  Â  Â  Â  for (let i = 0; i < positions.count; i++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const vertex = new THREE.Vector3();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  vertex.fromBufferAttribute(positions, i);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Random jitter
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  vertex.x += (Math.random() - 0.5) * 0.15;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  vertex.y += (Math.random() - 0.5) * 0.15;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  vertex.z += (Math.random() - 0.5) * 0.15;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  positions.setXYZ(i, vertex.x, vertex.y, vertex.z);
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  geometry.computeVertexNormals();

Â  Â  Â  Â  Â  Â  Â  Â  // Neon glowing material
Â  Â  Â  Â  Â  Â  Â  Â  const hue = (this.wave * 0.1) % 1;
Â  Â  Â  Â  Â  Â  Â  Â  const material = new THREE.MeshStandardMaterial({
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  color: new THREE.Color().setHSL(hue, 1, 0.5),
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  emissive: new THREE.Color().setHSL(hue, 1, 0.4),
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  emissiveIntensity: 2,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  metalness: 0.8,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  roughness: 0.2,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  wireframe: false
Â  Â  Â  Â  Â  Â  Â  Â  });

Â  Â  Â  Â  Â  Â  Â  Â  this.mesh = new THREE.Mesh(geometry, material);

Â  Â  Â  Â  Â  Â  Â  Â  // Add wireframe overlay for extra glitch effect
Â  Â  Â  Â  Â  Â  Â  Â  const wireframeGeo = geometry.clone();
Â  Â  Â  Â  Â  Â  Â  Â  const wireframeMat = new THREE.MeshBasicMaterial({
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  color: new THREE.Color().setHSL(hue, 1, 0.7),
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  wireframe: true,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  transparent: true,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  opacity: 0.3
Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  Â  Â  this.wireframe = new THREE.Mesh(wireframeGeo, wireframeMat);
Â  Â  Â  Â  Â  Â  Â  Â  this.mesh.add(this.wireframe);
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  applySlow(amount, duration) {
Â  Â  Â  Â  Â  Â  Â  Â  this.slowUntil = Math.max(this.slowUntil, Date.now() + duration);
Â  Â  Â  Â  Â  Â  Â  Â  this.speed = this.baseSpeed * (1 - amount);
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  applyPoison(damage, duration) {
Â  Â  Â  Â  Â  Â  Â  Â  this.poisonStacks.push({
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  damage: damage,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  endTime: Date.now() + duration,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  lastTick: Date.now()
Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  takeDamage(amount) {
Â  Â  Â  Â  Â  Â  Â  Â  this.health -= amount;

Â  Â  Â  Â  Â  Â  Â  Â  if (this.health <= 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.alive = false;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.die();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return true;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  return false;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  die() {
Â  Â  Â  Â  Â  Â  Â  Â  // Shrink and fade effect
Â  Â  Â  Â  Â  Â  Â  Â  const fadeOut = () => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.mesh.scale.multiplyScalar(0.9);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.mesh.material.opacity -= 0.1;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.mesh.material.transparent = true;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (this.mesh.material.opacity > 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  requestAnimationFrame(fadeOut);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  };
Â  Â  Â  Â  Â  Â  Â  Â  fadeOut();
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  update() {
Â  Â  Â  Â  Â  Â  Â  Â  if (!this.alive) return false;

Â  Â  Â  Â  Â  Â  Â  Â  // Update slow effect
Â  Â  Â  Â  Â  Â  Â  Â  if (Date.now() > this.slowUntil) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.speed = this.baseSpeed;
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  // Update poison effects
Â  Â  Â  Â  Â  Â  Â  Â  const currentTime = Date.now();
Â  Â  Â  Â  Â  Â  Â  Â  for (let i = this.poisonStacks.length - 1; i >= 0; i--) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const poison = this.poisonStacks[i];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (currentTime > poison.endTime) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.poisonStacks.splice(i, 1);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else if (currentTime - poison.lastTick >= 500) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  poison.lastTick = currentTime;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.takeDamage(poison.damage);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  // Rotate for digital glitch effect
Â  Â  Â  Â  Â  Â  Â  Â  this.mesh.rotation.x += this.rotationSpeed;
Â  Â  Â  Â  Â  Â  Â  Â  this.mesh.rotation.y += this.rotationSpeed * 1.5;

Â  Â  Â  Â  Â  Â  Â  Â  const currentTarget = this.path[this.pathIndex];
Â  Â  Â  Â  Â  Â  Â  Â  const targetWorldPos = new THREE.Vector3(
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  currentTarget.x - CONFIG.GRID_SIZE/2 + 0.5,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  0.4,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  currentTarget.z - CONFIG.GRID_SIZE/2 + 0.5
Â  Â  Â  Â  Â  Â  Â  Â  );

Â  Â  Â  Â  Â  Â  Â  Â  const direction = targetWorldPos.clone().sub(this.mesh.position);
Â  Â  Â  Â  Â  Â  Â  Â  const distance = direction.length();

Â  Â  Â  Â  Â  Â  Â  Â  if (distance < 0.1) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.pathIndex++;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (this.pathIndex >= this.path.length) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.alive = false;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return 'escaped';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  direction.normalize();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.mesh.position.add(direction.multiplyScalar(this.speed));
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  return true;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  destroy() {
Â  Â  Â  Â  Â  Â  Â  Â  this.scene.remove(this.mesh);
Â  Â  Â  Â  Â  Â  Â  Â  this.mesh.geometry.dispose();
Â  Â  Â  Â  Â  Â  Â  Â  this.mesh.material.dispose();
Â  Â  Â  Â  Â  Â  Â  Â  if (this.wireframe) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.wireframe.geometry.dispose();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.wireframe.material.dispose();
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }

Â  Â  Â  Â  // ============================================
Â  Â  Â  Â  // PROCEDURAL MONOLITH TOWER CLASS
Â  Â  Â  Â  // ============================================
Â  Â  Â  Â  class Tower {
Â  Â  Â  Â  Â  Â  constructor(scene, gridX, gridZ) {
Â  Â  Â  Â  Â  Â  Â  Â  this.scene = scene;
Â  Â  Â  Â  Â  Â  Â  Â  this.gridX = gridX;
Â  Â  Â  Â  Â  Â  Â  Â  this.gridZ = gridZ;
Â  Â  Â  Â  Â  Â  Â  Â  this.level = 1;
Â  Â  Â  Â  Â  Â  Â  Â  this.range = 3.0;
Â  Â  Â  Â  Â  Â  Â  Â  this.fireRate = 1.0;
Â  Â  Â  Â  Â  Â  Â  Â  this.damage = 1;
Â  Â  Â  Â  Â  Â  Â  Â  this.lastFireTime = 0;
Â  Â  Â  Â  Â  Â  Â  Â  this.upgradeCost = 150;
Â  Â  Â  Â  Â  Â  Â  Â  this.specialization = null;
Â  Â  Â  Â  Â  Â  Â  Â  this.maxLevel = null;

Â  Â  Â  Â  Â  Â  Â  Â  // Specialization stats
Â  Â  Â  Â  Â  Â  Â  Â  this.slowAmount = 0;
Â  Â  Â  Â  Â  Â  Â  Â  this.slowDuration = 0;
Â  Â  Â  Â  Â  Â  Â  Â  this.poisonDamage = 0;
Â  Â  Â  Â  Â  Â  Â  Â  this.poisonDuration = 0;
Â  Â  Â  Â  Â  Â  Â  Â  this.splashRadius = 0;

Â  Â  Â  Â  Â  Â  Â  Â  // Animation properties
Â  Â  Â  Â  Â  Â  Â  Â  this.time = Math.random() * Math.PI * 2;
Â  Â  Â  Â  Â  Â  Â  Â  this.hoverSpeed = 1.5;
Â  Â  Â  Â  Â  Â  Â  Â  this.hoverAmplitude = 0.15;
Â  Â  Â  Â  Â  Â  Â  Â  this.baseY = CONFIG.ELEVATION_HEIGHT + 0.5;

Â  Â  Â  Â  Â  Â  Â  Â  // Toy lunge properties
Â  Â  Â  Â  Â  Â  Â  Â  this.isLunging = false;
Â  Â  Â  Â  Â  Â  Â  Â  this.lungeTarget = null;
Â  Â  Â  Â  Â  Â  Â  Â  this.originalPosition = new THREE.Vector3();

Â  Â  Â  Â  Â  Â  Â  Â  // Create tower group
Â  Â  Â  Â  Â  Â  Â  Â  this.group = new THREE.Group();
Â  Â  Â  Â  Â  Â  Â  Â  this.createTowerGeometry(this.level);

Â  Â  Â  Â  Â  Â  Â  Â  const worldPos = this.gridToWorld(gridX, gridZ);
Â  Â  Â  Â  Â  Â  Â  Â  this.group.position.set(worldPos.x, this.baseY, worldPos.z);
Â  Â  Â  Â  Â  Â  Â  Â  this.originalPosition.copy(this.group.position);

Â  Â  Â  Â  Â  Â  Â  Â  this.scene.add(this.group);
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  createTowerGeometry(level) {
Â  Â  Â  Â  Â  Â  Â  Â  // Clear existing geometry
Â  Â  Â  Â  Â  Â  Â  Â  while(this.group.children.length > 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const child = this.group.children[0];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.group.remove(child);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (child.geometry) child.geometry.dispose();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (child.material) child.material.dispose();
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  // Determine color based on specialization
Â  Â  Â  Â  Â  Â  Â  Â  let towerColor = 0x00ffff;
Â  Â  Â  Â  Â  Â  Â  Â  let emissiveColor = 0x00ffff;

Â  Â  Â  Â  Â  Â  Â  Â  if (this.specialization) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  switch(this.specialization) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  case 'rapidfire':
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  towerColor = 0xff3333;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  emissiveColor = 0xff3333;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  break;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  case 'sniper':
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  towerColor = 0x4a90e2;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  emissiveColor = 0x4a90e2;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  break;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  case 'frost':
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  towerColor = 0x74b9ff;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  emissiveColor = 0x74b9ff;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  break;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  case 'splash':
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  towerColor = 0xff7f50;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  emissiveColor = 0xff7f50;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  break;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  case 'poison':
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  towerColor = 0x6c5ce7;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  emissiveColor = 0x6c5ce7;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  break;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  // PEDESTAL - 1:1 scale BoxGeometry with perfect UV mapping
Â  Â  Â  Â  Â  Â  Â  Â  const pedestalGeo = new THREE.BoxGeometry(1, 0.2, 1);
Â  Â  Â  Â  Â  Â  Â  Â  pedestalGeo.computeBoundingBox();

Â  Â  Â  Â  Â  Â  Â  Â  const pedestalMat = new THREE.MeshStandardMaterial({
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  color: towerColor,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  emissive: emissiveColor,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  emissiveIntensity: 0.5,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  metalness: 0.7,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  roughness: 0.3,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Ready for texture: map: textureLoader.load('your-pattern.jpg')
Â  Â  Â  Â  Â  Â  Â  Â  });

Â  Â  Â  Â  Â  Â  Â  Â  this.pedestal = new THREE.Mesh(pedestalGeo, pedestalMat);
Â  Â  Â  Â  Â  Â  Â  Â  this.pedestal.position.y = -0.5;
Â  Â  Â  Â  Â  Â  Â  Â  this.group.add(this.pedestal);

Â  Â  Â  Â  Â  Â  Â  Â  // Add glowing border to pedestal
Â  Â  Â  Â  Â  Â  Â  Â  const borderGeo = new THREE.EdgesGeometry(pedestalGeo);
Â  Â  Â  Â  Â  Â  Â  Â  const borderMat = new THREE.LineBasicMaterial({
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  color: towerColor,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  linewidth: 2
Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  Â  Â  const border = new THREE.LineSegments(borderGeo, borderMat);
Â  Â  Â  Â  Â  Â  Â  Â  this.pedestal.add(border);

Â  Â  Â  Â  Â  Â  Â  Â  // BEVELED BASE - Cone shape for anti-clipping
Â  Â  Â  Â  Â  Â  Â  Â  const bevelGeo = new THREE.CylinderGeometry(0.4, 0.5, 0.15, 8);
Â  Â  Â  Â  Â  Â  Â  Â  const bevelMat = new THREE.MeshStandardMaterial({
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  color: towerColor,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  emissive: emissiveColor,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  emissiveIntensity: 0.7,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  metalness: 0.8,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  roughness: 0.3
Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  Â  Â  this.bevel = new THREE.Mesh(bevelGeo, bevelMat);
Â  Â  Â  Â  Â  Â  Â  Â  this.bevel.position.y = -0.25;
Â  Â  Â  Â  Â  Â  Â  Â  this.group.add(this.bevel);

Â  Â  Â  Â  Â  Â  Â  Â  // TOWER BODY - Changes with level
Â  Â  Â  Â  Â  Â  Â  Â  let bodyGeo, topGeo;

Â  Â  Â  Â  Â  Â  Â  Â  if (level === 1) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Level 1: Simple Cube
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  bodyGeo = new THREE.BoxGeometry(0.6, 0.8, 0.6);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  topGeo = new THREE.ConeGeometry(0.35, 0.4, 4);
Â  Â  Â  Â  Â  Â  Â  Â  } else if (level === 2) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Level 2: Octahedron
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  bodyGeo = new THREE.OctahedronGeometry(0.5);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  topGeo = new THREE.CylinderGeometry(0.2, 0.2, 0.5, 8);
Â  Â  Â  Â  Â  Â  Â  Â  } else if (level === 3) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Level 3: Complex shape
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  bodyGeo = new THREE.DodecahedronGeometry(0.45);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  topGeo = new THREE.TorusGeometry(0.25, 0.1, 8, 8);
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Level 4+: Advanced geometry
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  bodyGeo = new THREE.IcosahedronGeometry(0.5, 0);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  topGeo = new THREE.OctahedronGeometry(0.3);
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  const bodyMat = new THREE.MeshStandardMaterial({
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  color: towerColor,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  emissive: emissiveColor,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  emissiveIntensity: 1,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  metalness: 0.8,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  roughness: 0.2,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Ready for texture: map: textureLoader.load('your-pattern.jpg')
Â  Â  Â  Â  Â  Â  Â  Â  });

Â  Â  Â  Â  Â  Â  Â  Â  this.towerBody = new THREE.Mesh(bodyGeo, bodyMat);
Â  Â  Â  Â  Â  Â  Â  Â  this.towerBody.position.y = 0.2;
Â  Â  Â  Â  Â  Â  Â  Â  this.group.add(this.towerBody);

Â  Â  Â  Â  Â  Â  Â  Â  // Add body border
Â  Â  Â  Â  Â  Â  Â  Â  const bodyBorderGeo = new THREE.EdgesGeometry(bodyGeo);
Â  Â  Â  Â  Â  Â  Â  Â  const bodyBorderMat = new THREE.LineBasicMaterial({
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  color: towerColor,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  linewidth: 2
Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  Â  Â  const bodyBorder = new THREE.LineSegments(bodyBorderGeo, bodyBorderMat);
Â  Â  Â  Â  Â  Â  Â  Â  this.towerBody.add(bodyBorder);

Â  Â  Â  Â  Â  Â  Â  Â  // ROTATING TOP ELEMENT
Â  Â  Â  Â  Â  Â  Â  Â  const topMat = new THREE.MeshStandardMaterial({
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  color: towerColor,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  emissive: emissiveColor,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  emissiveIntensity: 1.5,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  metalness: 0.9,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  roughness: 0.1
Â  Â  Â  Â  Â  Â  Â  Â  });

Â  Â  Â  Â  Â  Â  Â  Â  this.towerTop = new THREE.Mesh(topGeo, topMat);
Â  Â  Â  Â  Â  Â  Â  Â  this.towerTop.position.y = 0.8;
Â  Â  Â  Â  Â  Â  Â  Â  this.group.add(this.towerTop);

Â  Â  Â  Â  Â  Â  Â  Â  // Add range indicator
Â  Â  Â  Â  Â  Â  Â  Â  this.createRangeIndicator();
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  createRangeIndicator() {
Â  Â  Â  Â  Â  Â  Â  Â  const geometry = new THREE.RingGeometry(this.range - 0.1, this.range, 32);
Â  Â  Â  Â  Â  Â  Â  Â  const material = new THREE.MeshBasicMaterial({
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  color: this.specialization ? this.getColorForSpecialization() : 0x00ffff,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  transparent: true,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  opacity: 0.15,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  side: THREE.DoubleSide
Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  Â  Â  this.rangeIndicator = new THREE.Mesh(geometry, material);
Â  Â  Â  Â  Â  Â  Â  Â  this.rangeIndicator.rotation.x = -Math.PI / 2;
Â  Â  Â  Â  Â  Â  Â  Â  this.rangeIndicator.position.y = -this.baseY + 0.1;
Â  Â  Â  Â  Â  Â  Â  Â  this.group.add(this.rangeIndicator);
Â  Â  Â  Â  Â  Â  Â  Â  this.rangeIndicator.visible = false;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  getColorForSpecialization() {
Â  Â  Â  Â  Â  Â  Â  Â  if (!this.specialization) return 0x00ffff;
Â  Â  Â  Â  Â  Â  Â  Â  switch(this.specialization) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  case 'rapidfire': return 0xff3333;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  case 'sniper': return 0x4a90e2;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  case 'frost': return 0x74b9ff;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  case 'splash': return 0xff7f50;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  case 'poison': return 0x6c5ce7;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  default: return 0x00ffff;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  gridToWorld(x, z) {
Â  Â  Â  Â  Â  Â  Â  Â  return {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  x: x - CONFIG.GRID_SIZE/2 + 0.5,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  z: z - CONFIG.GRID_SIZE/2 + 0.5
Â  Â  Â  Â  Â  Â  Â  Â  };
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  specialize(type) {
Â  Â  Â  Â  Â  Â  Â  Â  this.specialization = type;
Â  Â  Â  Â  Â  Â  Â  Â  this.level = 2;
Â  Â  Â  Â  Â  Â  Â  Â  this.upgradeCost = 150;
Â  Â  Â  Â  Â  Â  Â  Â  this.maxLevel = 5;

Â  Â  Â  Â  Â  Â  Â  Â  switch(type) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  case 'rapidfire':
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.fireRate = 3.0;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.damage = 1;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.range = 2.5;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  break;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  case 'sniper':
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.fireRate = 0.5;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.damage = 5;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.range = 6.0;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  break;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  case 'frost':
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.fireRate = 1.2;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.damage = 1;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.range = 3.5;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.slowAmount = 0.5;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.slowDuration = 2000;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  break;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  case 'splash':
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.fireRate = 0.8;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.damage = 2;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.range = 3.5;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.splashRadius = 1.5;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  break;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  case 'poison':
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.fireRate = 1.0;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.damage = 1;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.range = 3.0;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.poisonDamage = 0.5;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.poisonDuration = 3000;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  break;
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  // Rebuild geometry with specialization color
Â  Â  Â  Â  Â  Â  Â  Â  this.createTowerGeometry(this.level);

Â  Â  Â  Â  Â  Â  Â  Â  // Update range indicator
Â  Â  Â  Â  Â  Â  Â  Â  if (this.rangeIndicator) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.rangeIndicator.geometry.dispose();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const geometry = new THREE.RingGeometry(this.range - 0.1, this.range, 32);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.rangeIndicator.geometry = geometry;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.rangeIndicator.material.color.setHex(this.getColorForSpecialization());
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  upgrade() {
Â  Â  Â  Â  Â  Â  Â  Â  // Check if at max level
Â  Â  Â  Â  Â  Â  Â  Â  if (this.maxLevel && this.level >= this.maxLevel) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return false;
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  this.level++;

Â  Â  Â  Â  Â  Â  Â  Â  // Scale upgrade cost: 150 -> 250 -> 400 -> 650
Â  Â  Â  Â  Â  Â  Â  Â  this.upgradeCost = Math.floor(this.upgradeCost * 1.7);

Â  Â  Â  Â  Â  Â  Â  Â  if (!this.specialization) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Basic tower upgrade
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.range += 0.5;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.fireRate += 0.3;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.damage += 1;
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Specialized tower upgrade
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  switch(this.specialization) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  case 'rapidfire':
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.fireRate += 0.8;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.damage += 0.5;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  break;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  case 'sniper':
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.damage += 3;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.range += 0.5;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  break;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  case 'frost':
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.slowAmount = Math.min(0.8, this.slowAmount + 0.1);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.slowDuration += 500;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.damage += 0.5;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  break;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  case 'splash':
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.damage += 1;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.splashRadius += 0.3;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  break;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  case 'poison':
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.poisonDamage += 0.3;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.poisonDuration += 500;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.damage += 0.5;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  break;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  // Rebuild geometry with new level
Â  Â  Â  Â  Â  Â  Â  Â  this.createTowerGeometry(this.level);

Â  Â  Â  Â  Â  Â  Â  Â  // Update range indicator
Â  Â  Â  Â  Â  Â  Â  Â  if (this.rangeIndicator) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.rangeIndicator.geometry.dispose();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const geometry = new THREE.RingGeometry(this.range - 0.1, this.range, 32);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.rangeIndicator.geometry = geometry;
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  return true;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  findTarget(enemies) {
Â  Â  Â  Â  Â  Â  Â  Â  let furthestEnemy = null;
Â  Â  Â  Â  Â  Â  Â  Â  let maxDistance = 0;

Â  Â  Â  Â  Â  Â  Â  Â  for (const enemy of enemies) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (!enemy.alive) continue;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const distance = this.group.position.distanceTo(enemy.mesh.position);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (distance <= this.range && enemy.pathIndex > maxDistance) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  maxDistance = enemy.pathIndex;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  furthestEnemy = enemy;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  return furthestEnemy;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  toyLunge(target) {
Â  Â  Â  Â  Â  Â  Â  Â  // Store target for lunge animation
Â  Â  Â  Â  Â  Â  Â  Â  this.lungeTarget = target.mesh.position.clone();

Â  Â  Â  Â  Â  Â  Â  Â  // Calculate lunge direction
Â  Â  Â  Â  Â  Â  Â  Â  const direction = this.lungeTarget.clone().sub(this.group.position).normalize();
Â  Â  Â  Â  Â  Â  Â  Â  direction.y = 0; // Keep vertical position

Â  Â  Â  Â  Â  Â  Â  Â  // Lunge 0.15 units toward target
Â  Â  Â  Â  Â  Â  Â  Â  const lungePos = this.group.position.clone().add(direction.multiplyScalar(0.15));
Â  Â  Â  Â  Â  Â  Â  Â  this.group.position.copy(lungePos);

Â  Â  Â  Â  Â  Â  Â  Â  // Snap back immediately (next frame)
Â  Â  Â  Â  Â  Â  Â  Â  setTimeout(() => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.group.position.copy(this.originalPosition);
Â  Â  Â  Â  Â  Â  Â  Â  }, 16);
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  shoot(target, currentTime, enemies) {
Â  Â  Â  Â  Â  Â  Â  Â  const timeSinceLastShot = (currentTime - this.lastFireTime) / 1000;
Â  Â  Â  Â  Â  Â  Â  Â  if (timeSinceLastShot < 1 / this.fireRate) return null;

Â  Â  Â  Â  Â  Â  Â  Â  this.lastFireTime = currentTime;

Â  Â  Â  Â  Â  Â  Â  Â  // TOY LUNGE MECHANIC
Â  Â  Â  Â  Â  Â  Â  Â  this.toyLunge(target);

Â  Â  Â  Â  Â  Â  Â  Â  // Apply damage
Â  Â  Â  Â  Â  Â  Â  Â  target.takeDamage(this.damage);

Â  Â  Â  Â  Â  Â  Â  Â  // Apply special effects
Â  Â  Â  Â  Â  Â  Â  Â  if (this.specialization === 'frost') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  target.applySlow(this.slowAmount, this.slowDuration);
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  if (this.specialization === 'poison') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  target.applyPoison(this.poisonDamage, this.poisonDuration);
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  if (this.specialization === 'splash' && this.splashRadius > 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Deal splash damage to nearby enemies
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  for (const enemy of enemies) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (enemy === target || !enemy.alive) continue;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const distance = target.mesh.position.distanceTo(enemy.mesh.position);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (distance <= this.splashRadius) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  enemy.takeDamage(this.damage * 0.5);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  // Return shot data for projectile
Â  Â  Â  Â  Â  Â  Â  Â  return {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  from: this.group.position.clone(),
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  to: target.mesh.position.clone(),
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  specialization: this.specialization
Â  Â  Â  Â  Â  Â  Â  Â  };
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  showRange(visible) {
Â  Â  Â  Â  Â  Â  Â  Â  if (this.rangeIndicator) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.rangeIndicator.visible = visible;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  update(enemies, currentTime, deltaTime) {
Â  Â  Â  Â  Â  Â  Â  Â  // Sine-wave hover effect
Â  Â  Â  Â  Â  Â  Â  Â  this.time += deltaTime * this.hoverSpeed;
Â  Â  Â  Â  Â  Â  Â  Â  const hover = Math.sin(this.time) * this.hoverAmplitude;
Â  Â  Â  Â  Â  Â  Â  Â  this.group.position.y = this.baseY + hover;

Â  Â  Â  Â  Â  Â  Â  Â  // Update original position for lunge
Â  Â  Â  Â  Â  Â  Â  Â  this.originalPosition.y = this.baseY + hover;

Â  Â  Â  Â  Â  Â  Â  Â  // Constant rotation for top element
Â  Â  Â  Â  Â  Â  Â  Â  if (this.towerTop) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.towerTop.rotation.y += deltaTime * 2;
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  // Find and shoot target
Â  Â  Â  Â  Â  Â  Â  Â  const target = this.findTarget(enemies);
Â  Â  Â  Â  Â  Â  Â  Â  if (target) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Rotate body to face target
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const lookTarget = target.mesh.position.clone();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  lookTarget.y = this.towerBody.position.y;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.towerBody.lookAt(lookTarget);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return this.shoot(target, currentTime, enemies);
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  return null;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  destroy() {
Â  Â  Â  Â  Â  Â  Â  Â  this.scene.remove(this.group);
Â  Â  Â  Â  Â  Â  Â  Â  this.group.traverse((child) => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (child.geometry) child.geometry.dispose();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (child.material) child.material.dispose();
Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }

Â  Â  Â  Â  // ============================================
Â  Â  Â  Â  // GLOWING PROJECTILE CLASS
Â  Â  Â  Â  // ============================================
Â  Â  Â  Â  class Projectile {
Â  Â  Â  Â  Â  Â  constructor(scene, from, to, specialization) {
Â  Â  Â  Â  Â  Â  Â  Â  this.scene = scene;
Â  Â  Â  Â  Â  Â  Â  Â  this.lifetime = 300;
Â  Â  Â  Â  Â  Â  Â  Â  this.createdAt = Date.now();

Â  Â  Â  Â  Â  Â  Â  Â  // Choose color based on specialization
Â  Â  Â  Â  Â  Â  Â  Â  let color = 0x00ffff;
Â  Â  Â  Â  Â  Â  Â  Â  switch(specialization) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  case 'rapidfire': color = 0xff3333; break;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  case 'sniper': color = 0x4a90e2; break;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  case 'frost': color = 0x74b9ff; break;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  case 'splash': color = 0xff7f50; break;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  case 'poison': color = 0x6c5ce7; break;
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  // Create glowing line segment
Â  Â  Â  Â  Â  Â  Â  Â  const geometry = new THREE.BufferGeometry().setFromPoints([from, to]);
Â  Â  Â  Â  Â  Â  Â  Â  const material = new THREE.LineBasicMaterial({
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  color: color,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  linewidth: 3,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  transparent: true,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  opacity: 1
Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  Â  Â  this.line = new THREE.Line(geometry, material);

Â  Â  Â  Â  Â  Â  Â  Â  // Add glow effect with multiple lines
Â  Â  Â  Â  Â  Â  Â  Â  const glowMat = new THREE.LineBasicMaterial({
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  color: color,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  linewidth: 6,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  transparent: true,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  opacity: 0.3
Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  Â  Â  this.glowLine = new THREE.Line(geometry.clone(), glowMat);

Â  Â  Â  Â  Â  Â  Â  Â  this.scene.add(this.line);
Â  Â  Â  Â  Â  Â  Â  Â  this.scene.add(this.glowLine);
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  update() {
Â  Â  Â  Â  Â  Â  Â  Â  const age = Date.now() - this.createdAt;
Â  Â  Â  Â  Â  Â  Â  Â  if (age > this.lifetime) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.destroy();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return false;
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  // Fade out quickly
Â  Â  Â  Â  Â  Â  Â  Â  const fadeAmount = 1 - (age / this.lifetime);
Â  Â  Â  Â  Â  Â  Â  Â  this.line.material.opacity = fadeAmount;
Â  Â  Â  Â  Â  Â  Â  Â  this.glowLine.material.opacity = fadeAmount * 0.3;

Â  Â  Â  Â  Â  Â  Â  Â  return true;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  destroy() {
Â  Â  Â  Â  Â  Â  Â  Â  this.scene.remove(this.line);
Â  Â  Â  Â  Â  Â  Â  Â  this.scene.remove(this.glowLine);
Â  Â  Â  Â  Â  Â  Â  Â  this.line.geometry.dispose();
Â  Â  Â  Â  Â  Â  Â  Â  this.line.material.dispose();
Â  Â  Â  Â  Â  Â  Â  Â  this.glowLine.geometry.dispose();
Â  Â  Â  Â  Â  Â  Â  Â  this.glowLine.material.dispose();
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }

Â  Â  Â  Â  // ============================================
Â  Â  Â  Â  // GAME MANAGER
Â  Â  Â  Â  // ============================================
Â  Â  Â  Â  class GameManager {
Â  Â  Â  Â  Â  Â  constructor() {
Â  Â  Â  Â  Â  Â  Â  Â  this.scene = null;
Â  Â  Â  Â  Â  Â  Â  Â  this.camera = null;
Â  Â  Â  Â  Â  Â  Â  Â  this.renderer = null;
Â  Â  Â  Â  Â  Â  Â  Â  this.composer = null;
Â  Â  Â  Â  Â  Â  Â  Â  this.raycaster = new THREE.Raycaster();
Â  Â  Â  Â  Â  Â  Â  Â  this.mouse = new THREE.Vector2();
Â  Â  Â  Â  Â  Â  Â  Â  this.clock = new THREE.Clock();

Â  Â  Â  Â  Â  Â  Â  Â  this.grid = [];
Â  Â  Â  Â  Â  Â  Â  Â  this.towers = [];
Â  Â  Â  Â  Â  Â  Â  Â  this.enemies = [];
Â  Â  Â  Â  Â  Â  Â  Â  this.projectiles = [];

Â  Â  Â  Â  Â  Â  Â  Â  this.gold = CONFIG.INITIAL_GOLD;
Â  Â  Â  Â  Â  Â  Â  Â  this.lives = CONFIG.INITIAL_LIVES;
Â  Â  Â  Â  Â  Â  Â  Â  this.wave = 0;
Â  Â  Â  Â  Â  Â  Â  Â  this.waveInProgress = false;
Â  Â  Â  Â  Â  Â  Â  Â  this.selectedTower = null;
Â  Â  Â  Â  Â  Â  Â  Â  this.pendingPlacement = null;

Â  Â  Â  Â  Â  Â  Â  Â  this.init();
Â  Â  Â  Â  Â  Â  Â  Â  this.setupEventListeners();
Â  Â  Â  Â  Â  Â  Â  Â  this.animate();
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  init() {
Â  Â  Â  Â  Â  Â  Â  Â  // Scene
Â  Â  Â  Â  Â  Â  Â  Â  this.scene = new THREE.Scene();
Â  Â  Â  Â  Â  Â  Â  Â  this.scene.background = new THREE.Color(0x000000);
Â  Â  Â  Â  Â  Â  Â  Â  this.scene.fog = new THREE.FogExp2(0x000011, 0.05);

Â  Â  Â  Â  Â  Â  Â  Â  // Orthographic Camera - Isometric 45-degree angle
Â  Â  Â  Â  Â  Â  Â  Â  const aspect = window.innerWidth / window.innerHeight;
Â  Â  Â  Â  Â  Â  Â  Â  const frustumSize = 12;
Â  Â  Â  Â  Â  Â  Â  Â  this.camera = new THREE.OrthographicCamera(
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  frustumSize * aspect / -2,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  frustumSize * aspect / 2,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  frustumSize / 2,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  frustumSize / -2,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  0.1,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  1000
Â  Â  Â  Â  Â  Â  Â  Â  );
Â  Â  Â  Â  Â  Â  Â  Â  this.camera.position.set(10, 10, 10);
Â  Â  Â  Â  Â  Â  Â  Â  this.camera.lookAt(0, 0, 0);

Â  Â  Â  Â  Â  Â  Â  Â  // Renderer
Â  Â  Â  Â  Â  Â  Â  Â  const canvas = document.getElementById('gameCanvas');
Â  Â  Â  Â  Â  Â  Â  Â  this.renderer = new THREE.WebGLRenderer({
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  canvas,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  antialias: true
Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  Â  Â  this.renderer.setSize(window.innerWidth, window.innerHeight);
Â  Â  Â  Â  Â  Â  Â  Â  this.renderer.setPixelRatio(window.devicePixelRatio);

Â  Â  Â  Â  Â  Â  Â  Â  // Post-processing with UnrealBloomPass
Â  Â  Â  Â  Â  Â  Â  Â  this.composer = new EffectComposer(this.renderer);
Â  Â  Â  Â  Â  Â  Â  Â  const renderPass = new RenderPass(this.scene, this.camera);
Â  Â  Â  Â  Â  Â  Â  Â  this.composer.addPass(renderPass);

Â  Â  Â  Â  Â  Â  Â  Â  const bloomPass = new UnrealBloomPass(
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  new THREE.Vector2(window.innerWidth, window.innerHeight),
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  1.5,Â  // Strength
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  0.4,Â  // Radius
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  0.85Â  // Threshold
Â  Â  Â  Â  Â  Â  Â  Â  );
Â  Â  Â  Â  Â  Â  Â  Â  this.composer.addPass(bloomPass);

Â  Â  Â  Â  Â  Â  Â  Â  // Lights
Â  Â  Â  Â  Â  Â  Â  Â  const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
Â  Â  Â  Â  Â  Â  Â  Â  this.scene.add(ambientLight);

Â  Â  Â  Â  Â  Â  Â  Â  const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
Â  Â  Â  Â  Â  Â  Â  Â  directionalLight.position.set(5, 10, 5);
Â  Â  Â  Â  Â  Â  Â  Â  this.scene.add(directionalLight);

Â  Â  Â  Â  Â  Â  Â  Â  // Add point lights for neon atmosphere
Â  Â  Â  Â  Â  Â  Â  Â  const pointLight1 = new THREE.PointLight(0x00ffff, 2, 20);
Â  Â  Â  Â  Â  Â  Â  Â  pointLight1.position.set(-3, 3, -3);
Â  Â  Â  Â  Â  Â  Â  Â  this.scene.add(pointLight1);

Â  Â  Â  Â  Â  Â  Â  Â  const pointLight2 = new THREE.PointLight(0xff3333, 2, 20);
Â  Â  Â  Â  Â  Â  Â  Â  pointLight2.position.set(3, 3, 3);
Â  Â  Â  Â  Â  Â  Â  Â  this.scene.add(pointLight2);

Â  Â  Â  Â  Â  Â  Â  Â  // Create grid
Â  Â  Â  Â  Â  Â  Â  Â  this.createGrid();

Â  Â  Â  Â  Â  Â  Â  Â  // Update UI
Â  Â  Â  Â  Â  Â  Â  Â  this.updateUI();
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  createGrid() {
Â  Â  Â  Â  Â  Â  Â  Â  const pathSet = new Set(PATH.map(p => `${p.x},${p.z}`));

Â  Â  Â  Â  Â  Â  Â  Â  for (let x = 0; x < CONFIG.GRID_SIZE; x++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.grid[x] = [];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  for (let z = 0; z < CONFIG.GRID_SIZE; z++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const isPath = pathSet.has(`${x},${z}`);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const worldX = x - CONFIG.GRID_SIZE/2 + 0.5;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const worldZ = z - CONFIG.GRID_SIZE/2 + 0.5;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (isPath) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Glass-like path tiles
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const geometry = new THREE.BoxGeometry(
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  CONFIG.TILE_SIZE * 0.95,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  0.1,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  CONFIG.TILE_SIZE * 0.95
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  );
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const material = new THREE.MeshStandardMaterial({
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  color: 0x004466,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  emissive: 0x0088cc,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  emissiveIntensity: 0.5,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  metalness: 0.9,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  roughness: 0.1,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  transparent: true,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  opacity: 0.7
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const tile = new THREE.Mesh(geometry, material);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  tile.position.set(worldX, 0, worldZ);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.scene.add(tile);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Glowing border for path
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const borderGeo = new THREE.EdgesGeometry(geometry);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const borderMat = new THREE.LineBasicMaterial({
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  color: 0x00ffff,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  linewidth: 2
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const border = new THREE.LineSegments(borderGeo, borderMat);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  tile.add(border);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.grid[x][z] = { type: 'path', mesh: tile };
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Elevated buildable platform
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const geometry = new THREE.BoxGeometry(
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  CONFIG.TILE_SIZE,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  CONFIG.ELEVATION_HEIGHT,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  CONFIG.TILE_SIZE
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  );
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const material = new THREE.MeshStandardMaterial({
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  color: 0x1a1a2e,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  emissive: 0x0f0f1e,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  emissiveIntensity: 0.3,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  metalness: 0.6,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  roughness: 0.4,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Ready for texture: map: pattern
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const tile = new THREE.Mesh(geometry, material);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  tile.position.set(worldX, CONFIG.ELEVATION_HEIGHT/2, worldZ);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  tile.userData = { gridX: x, gridZ: z, buildable: true };
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.scene.add(tile);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Glowing circuit border
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const borderGeo = new THREE.EdgesGeometry(geometry);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const borderMat = new THREE.LineBasicMaterial({
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  color: 0x00ffff,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  linewidth: 2
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const border = new THREE.LineSegments(borderGeo, borderMat);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  border.material.transparent = true;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  border.material.opacity = 0.6;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  tile.add(border);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.grid[x][z] = { type: 'elevated', mesh: tile, tower: null };
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  setupEventListeners() {
Â  Â  Â  Â  Â  Â  Â  Â  window.addEventListener('resize', () => this.onWindowResize());
Â  Â  Â  Â  Â  Â  Â  Â  window.addEventListener('click', (e) => this.onClick(e));

Â  Â  Â  Â  Â  Â  Â  Â  document.getElementById('waveBtn').addEventListener('click', () => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.startWave();
Â  Â  Â  Â  Â  Â  Â  Â  });

Â  Â  Â  Â  Â  Â  Â  Â  document.getElementById('upgradeBtn').addEventListener('click', () => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.upgradeTower();
Â  Â  Â  Â  Â  Â  Â  Â  });

Â  Â  Â  Â  Â  Â  Â  Â  document.getElementById('closeBtn').addEventListener('click', () => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.closeUpgradePanel();
Â  Â  Â  Â  Â  Â  Â  Â  });

Â  Â  Â  Â  Â  Â  Â  Â  // Upgrade tree specialization options
Â  Â  Â  Â  Â  Â  Â  Â  const upgradeOptions = document.querySelectorAll('.upgrade-option');
Â  Â  Â  Â  Â  Â  Â  Â  upgradeOptions.forEach(option => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  option.addEventListener('click', (e) => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  e.stopPropagation();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (!this.selectedTower || this.selectedTower.specialization) return;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Remove previous selection
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  upgradeOptions.forEach(opt => opt.classList.remove('selected'));
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  option.classList.add('selected');

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const type = option.getAttribute('data-type');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.specializeTower(type);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  Â  Â  });

Â  Â  Â  Â  Â  Â  Â  Â  // Prevent clicks on panels
Â  Â  Â  Â  Â  Â  Â  Â  document.getElementById('upgradePanel').addEventListener('click', (e) => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  e.stopPropagation();
Â  Â  Â  Â  Â  Â  Â  Â  });

Â  Â  Â  Â  Â  Â  Â  Â  document.getElementById('confirmPanel').addEventListener('click', (e) => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  e.stopPropagation();
Â  Â  Â  Â  Â  Â  Â  Â  });

Â  Â  Â  Â  Â  Â  Â  Â  document.getElementById('confirmBuildBtn').addEventListener('click', (e) => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  e.stopPropagation();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.confirmTowerPlacement();
Â  Â  Â  Â  Â  Â  Â  Â  });

Â  Â  Â  Â  Â  Â  Â  Â  document.getElementById('cancelBuildBtn').addEventListener('click', (e) => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  e.stopPropagation();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.cancelTowerPlacement();
Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  onWindowResize() {
Â  Â  Â  Â  Â  Â  Â  Â  const aspect = window.innerWidth / window.innerHeight;
Â  Â  Â  Â  Â  Â  Â  Â  const frustumSize = 12;
Â  Â  Â  Â  Â  Â  Â  Â  this.camera.left = frustumSize * aspect / -2;
Â  Â  Â  Â  Â  Â  Â  Â  this.camera.right = frustumSize * aspect / 2;
Â  Â  Â  Â  Â  Â  Â  Â  this.camera.top = frustumSize / 2;
Â  Â  Â  Â  Â  Â  Â  Â  this.camera.bottom = frustumSize / -2;
Â  Â  Â  Â  Â  Â  Â  Â  this.camera.updateProjectionMatrix();
Â  Â  Â  Â  Â  Â  Â  Â  this.renderer.setSize(window.innerWidth, window.innerHeight);
Â  Â  Â  Â  Â  Â  Â  Â  this.composer.setSize(window.innerWidth, window.innerHeight);
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  onClick(event) {
Â  Â  Â  Â  Â  Â  Â  Â  this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
Â  Â  Â  Â  Â  Â  Â  Â  this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

Â  Â  Â  Â  Â  Â  Â  Â  this.raycaster.setFromCamera(this.mouse, this.camera);

Â  Â  Â  Â  Â  Â  Â  Â  // First, check ALL tiles (not just buildable) to determine which grid cell was clicked
Â  Â  Â  Â  Â  Â  Â  Â  const allTiles = [];
Â  Â  Â  Â  Â  Â  Â  Â  for (let x = 0; x < CONFIG.GRID_SIZE; x++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  for (let z = 0; z < CONFIG.GRID_SIZE; z++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const cell = this.grid[x][z];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (cell.type === 'elevated') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  allTiles.push(cell.mesh);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  const tileIntersects = this.raycaster.intersectObjects(allTiles, true);

Â  Â  Â  Â  Â  Â  Â  Â  if (tileIntersects.length > 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Find the tile mesh
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let tile = tileIntersects[0].object;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // If we clicked a child (border), get the parent tile
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  while (tile && !tile.userData.buildable) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  tile = tile.parent;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (tile && tile.userData.buildable) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const gridX = tile.userData.gridX;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const gridZ = tile.userData.gridZ;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const cell = this.grid[gridX][gridZ];

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Check if this tile has a tower
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (cell.tower) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.selectTower(cell.tower);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Otherwise, show placement confirmation if we have enough gold
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (this.gold >= CONFIG.TOWER_COST) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.showPlacementConfirmation(gridX, gridZ);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  // Close panels if clicking elsewhere
Â  Â  Â  Â  Â  Â  Â  Â  this.closeUpgradePanel();
Â  Â  Â  Â  Â  Â  Â  Â  this.cancelTowerPlacement();
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  showPlacementConfirmation(gridX, gridZ) {
Â  Â  Â  Â  Â  Â  Â  Â  // Close upgrade panel if open
Â  Â  Â  Â  Â  Â  Â  Â  this.closeUpgradePanel();

Â  Â  Â  Â  Â  Â  Â  Â  // Store pending placement
Â  Â  Â  Â  Â  Â  Â  Â  this.pendingPlacement = { gridX, gridZ };

Â  Â  Â  Â  Â  Â  Â  Â  // Show confirmation panel
Â  Â  Â  Â  Â  Â  Â  Â  document.getElementById('confirmPanel').style.display = 'block';
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  confirmTowerPlacement() {
Â  Â  Â  Â  Â  Â  Â  Â  if (!this.pendingPlacement) return;

Â  Â  Â  Â  Â  Â  Â  Â  const { gridX, gridZ } = this.pendingPlacement;
Â  Â  Â  Â  Â  Â  Â  Â  this.placeTower(gridX, gridZ);

Â  Â  Â  Â  Â  Â  Â  Â  // Close panel
Â  Â  Â  Â  Â  Â  Â  Â  document.getElementById('confirmPanel').style.display = 'none';
Â  Â  Â  Â  Â  Â  Â  Â  this.pendingPlacement = null;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  cancelTowerPlacement() {
Â  Â  Â  Â  Â  Â  Â  Â  document.getElementById('confirmPanel').style.display = 'none';
Â  Â  Â  Â  Â  Â  Â  Â  this.pendingPlacement = null;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  placeTower(gridX, gridZ) {
Â  Â  Â  Â  Â  Â  Â  Â  if (this.gold < CONFIG.TOWER_COST) return;

Â  Â  Â  Â  Â  Â  Â  Â  const cell = this.grid[gridX][gridZ];
Â  Â  Â  Â  Â  Â  Â  Â  if (cell.type === 'elevated' && !cell.tower) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.gold -= CONFIG.TOWER_COST;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const tower = new Tower(this.scene, gridX, gridZ);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.towers.push(tower);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  cell.tower = tower;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.updateUI();
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  selectTower(tower) {
Â  Â  Â  Â  Â  Â  Â  Â  // Hide range of previously selected tower
Â  Â  Â  Â  Â  Â  Â  Â  if (this.selectedTower) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.selectedTower.showRange(false);
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  this.selectedTower = tower;
Â  Â  Â  Â  Â  Â  Â  Â  tower.showRange(true);

Â  Â  Â  Â  Â  Â  Â  Â  // Show upgrade panel
Â  Â  Â  Â  Â  Â  Â  Â  document.getElementById('upgradePanel').style.display = 'block';
Â  Â  Â  Â  Â  Â  Â  Â  document.getElementById('towerLevel').textContent = tower.level;
Â  Â  Â  Â  Â  Â  Â  Â  document.getElementById('towerRange').textContent = tower.range.toFixed(1);
Â  Â  Â  Â  Â  Â  Â  Â  document.getElementById('towerFireRate').textContent = tower.fireRate.toFixed(1) + '/s';
Â  Â  Â  Â  Â  Â  Â  Â  document.getElementById('towerDamage').textContent = tower.damage.toFixed(1);

Â  Â  Â  Â  Â  Â  Â  Â  // Show specialization name
Â  Â  Â  Â  Â  Â  Â  Â  const specializationNames = {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  rapidfire: 'ğŸ”¥ Rapid Fire Tower',
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  sniper: 'ğŸ¯ Sniper Tower',
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  frost: 'â„ï¸ Frost Tower',
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  splash: 'ğŸ’¥ Splash Tower',
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  poison: 'â˜ ï¸ Poison Tower'
Â  Â  Â  Â  Â  Â  Â  Â  };
Â  Â  Â  Â  Â  Â  Â  Â  document.getElementById('towerSpecialization').textContent =
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  tower.specialization ? specializationNames[tower.specialization] : 'Basic Tower';

Â  Â  Â  Â  Â  Â  Â  Â  // Show/hide appropriate upgrade sections
Â  Â  Â  Â  Â  Â  Â  Â  if (tower.level === 1 && !tower.specialization) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Show specialization tree for level 1 towers
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  document.getElementById('upgradeTreeSection').style.display = 'block';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  document.getElementById('upgradeStandardSection').style.display = 'none';
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Show standard upgrade button
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  document.getElementById('upgradeTreeSection').style.display = 'none';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  document.getElementById('upgradeStandardSection').style.display = 'block';

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const upgradeBtn = document.getElementById('upgradeBtn');

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Check if at max level
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (tower.maxLevel && tower.level >= tower.maxLevel) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  upgradeBtn.textContent = 'MAX LEVEL';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  upgradeBtn.disabled = true;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  upgradeBtn.textContent = `â¬†ï¸ UPGRADE (${tower.upgradeCost}g)`;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  upgradeBtn.disabled = this.gold < tower.upgradeCost;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  specializeTower(type) {
Â  Â  Â  Â  Â  Â  Â  Â  if (!this.selectedTower) return;
Â  Â  Â  Â  Â  Â  Â  Â  if (this.gold < 100) return;

Â  Â  Â  Â  Â  Â  Â  Â  this.gold -= 100;
Â  Â  Â  Â  Â  Â  Â  Â  this.selectedTower.specialize(type);
Â  Â  Â  Â  Â  Â  Â  Â  this.updateUI();

Â  Â  Â  Â  Â  Â  Â  Â  // Close and reopen panel to update UI
Â  Â  Â  Â  Â  Â  Â  Â  this.closeUpgradePanel();
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  upgradeTower() {
Â  Â  Â  Â  Â  Â  Â  Â  if (!this.selectedTower) return;
Â  Â  Â  Â  Â  Â  Â  Â  if (this.gold < this.selectedTower.upgradeCost) return;

Â  Â  Â  Â  Â  Â  Â  Â  this.gold -= this.selectedTower.upgradeCost;
Â  Â  Â  Â  Â  Â  Â  Â  const upgraded = this.selectedTower.upgrade();

Â  Â  Â  Â  Â  Â  Â  Â  if (upgraded) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.updateUI();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Update panel
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.selectTower(this.selectedTower);
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  closeUpgradePanel() {
Â  Â  Â  Â  Â  Â  Â  Â  document.getElementById('upgradePanel').style.display = 'none';
Â  Â  Â  Â  Â  Â  Â  Â  if (this.selectedTower) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.selectedTower.showRange(false);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.selectedTower = null;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  startWave() {
Â  Â  Â  Â  Â  Â  Â  Â  if (this.waveInProgress) return;

Â  Â  Â  Â  Â  Â  Â  Â  this.wave++;
Â  Â  Â  Â  Â  Â  Â  Â  this.waveInProgress = true;
Â  Â  Â  Â  Â  Â  Â  Â  this.updateUI();

Â  Â  Â  Â  Â  Â  Â  Â  // Match original game's spawn logic
Â  Â  Â  Â  Â  Â  Â  Â  let enemyCount, spawnInterval;
Â  Â  Â  Â  Â  Â  Â  Â  if (this.wave === 1) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  enemyCount = 5;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  spawnInterval = 900;
Â  Â  Â  Â  Â  Â  Â  Â  } else if (this.wave === 2) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  enemyCount = 7;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  spawnInterval = 800;
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  enemyCount = 8 + this.wave * 3;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  spawnInterval = 700;
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  for (let i = 0; i < enemyCount; i++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  setTimeout(() => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const enemy = new Enemy(this.scene, PATH, this.wave);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.enemies.push(enemy);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }, i * spawnInterval);
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  // Check wave completion
Â  Â  Â  Â  Â  Â  Â  Â  setTimeout(() => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const checkComplete = setInterval(() => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const aliveEnemies = this.enemies.filter(e => e.alive);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (aliveEnemies.length === 0 && this.waveInProgress) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.waveInProgress = false;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  clearInterval(checkComplete);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }, 500);
Â  Â  Â  Â  Â  Â  Â  Â  }, enemyCount * spawnInterval + 5000);
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  updateUI() {
Â  Â  Â  Â  Â  Â  Â  Â  document.getElementById('gold').textContent = this.gold;
Â  Â  Â  Â  Â  Â  Â  Â  document.getElementById('lives').textContent = this.lives;
Â  Â  Â  Â  Â  Â  Â  Â  document.getElementById('wave').textContent = this.wave;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  update() {
Â  Â  Â  Â  Â  Â  Â  Â  const deltaTime = this.clock.getDelta();
Â  Â  Â  Â  Â  Â  Â  Â  const currentTime = Date.now();

Â  Â  Â  Â  Â  Â  Â  Â  // Update enemies
Â  Â  Â  Â  Â  Â  Â  Â  for (let i = this.enemies.length - 1; i >= 0; i--) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const enemy = this.enemies[i];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const result = enemy.update();

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (result === 'escaped') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.lives--;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.updateUI();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  enemy.destroy();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.enemies.splice(i, 1);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (this.lives <= 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  alert('ğŸ’€ GAME OVER ğŸ’€\nFinal Wave: ' + this.wave);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  location.reload();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else if (!enemy.alive) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.gold += enemy.reward;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.updateUI();

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Keep enemy for fade animation
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  setTimeout(() => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  enemy.destroy();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const index = this.enemies.indexOf(enemy);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (index > -1) this.enemies.splice(index, 1);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }, 500);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  // Update towers
Â  Â  Â  Â  Â  Â  Â  Â  for (const tower of this.towers) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const shot = tower.update(this.enemies, currentTime, deltaTime);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (shot) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const projectile = new Projectile(this.scene, shot.from, shot.to, shot.specialization);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.projectiles.push(projectile);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  // Update projectiles
Â  Â  Â  Â  Â  Â  Â  Â  for (let i = this.projectiles.length - 1; i >= 0; i--) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (!this.projectiles[i].update()) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.projectiles.splice(i, 1);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  animate() {
Â  Â  Â  Â  Â  Â  Â  Â  requestAnimationFrame(() => this.animate());
Â  Â  Â  Â  Â  Â  Â  Â  this.update();
Â  Â  Â  Â  Â  Â  Â  Â  this.composer.render();
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }

Â  Â  Â  Â  // ============================================
Â  Â  Â  Â  // START GAME
Â  Â  Â  Â  // ============================================
Â  Â  Â  Â  const game = new GameManager();

Â  Â  Â  Â  console.log('âš¡ GEOMETRIC GALAXY TD LOADED âš¡');
Â  Â  Â  Â  console.log('ğŸ¨ Ready for Spoonflower patterns');
Â  Â  Â  Â  console.log('ğŸ“¦ Tower pedestal UV mapped for textures');
Â  Â  Â  Â  console.log('âœ¨ UnrealBloomPass active for neon glow');
Â  Â  Â  Â  console.log('ğŸ”¥ Full upgrade tree with 5 specializations');
Â  Â  </script>
</body>
</html>
