<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Geometric Galaxy Tower Defense - Pattern Ripple</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            overflow: hidden;
            background: #000;
        }

        #gameCanvas {
            display: block;
            width: 100%;
            height: 100vh;
        }

        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #00ffff;
            font-size: 11px;
            background: rgba(0, 0, 0, 0.85);
            padding: 8px 12px;
            border-radius: 4px;
            border: 1px solid #00ffff;
            z-index: 100;
            font-weight: bold;
            text-shadow: 0 0 5px #00ffff;
        }

        #ui h2 {
            margin-bottom: 4px;
            color: #ff3333;
            font-size: 13px;
            text-shadow: 0 0 10px #ff3333;
        }

        #ui p {
            margin: 2px 0;
            line-height: 1.3;
        }

        #ui .info {
            font-size: 9px;
            color: #888;
            margin-top: 4px;
            line-height: 1.2;
        }

        #upgradePanel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 30px;
            border-radius: 10px;
            border: 3px solid #00ffff;
            color: #00ffff;
            display: none;
            z-index: 200;
            min-width: 400px;
            max-width: 500px;
            text-shadow: 0 0 5px #00ffff;
        }

        #upgradePanel h3 {
            margin-bottom: 20px;
            color: #ff3333;
            text-align: center;
            font-size: 24px;
            text-shadow: 0 0 15px #ff3333;
        }

        #upgradePanel .specialization {
            margin: 20px 0;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            text-align: center;
        }

        #upgradePanel .specialization-label {
            font-size: 18px;
            color: #ff3333;
            font-weight: bold;
            margin-bottom: 10px;
            text-shadow: 0 0 10px #ff3333;
        }

        #upgradePanel .stat {
            margin: 10px 0;
            display: flex;
            justify-content: space-between;
            font-size: 16px;
        }

        #upgradePanel .upgrade-options {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 20px;
        }

        #upgradePanel .upgrade-option {
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid #00ffff;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
        }

        #upgradePanel .upgrade-option:hover {
            background: rgba(0, 255, 255, 0.2);
            box-shadow: 0 0 20px #00ffff;
            transform: scale(1.05);
        }

        #upgradePanel .upgrade-option.selected {
            background: rgba(0, 255, 255, 0.3);
            border-color: #00ffff;
        }

        #upgradePanel .upgrade-option h4 {
            margin-bottom: 8px;
            color: #00ffff;
            font-size: 14px;
        }

        #upgradePanel .upgrade-option p {
            font-size: 11px;
            color: #aaa;
            margin: 5px 0;
        }

        #upgradePanel .upgrade-option .cost {
            color: #ff3333;
            font-weight: bold;
            margin-top: 8px;
            text-shadow: 0 0 5px #ff3333;
        }

        #upgradePanel button {
            width: 100%;
            padding: 15px;
            margin-top: 15px;
            border: 2px solid #00ffff;
            border-radius: 5px;
            font-size: 16px;
            cursor: pointer;
            font-weight: bold;
            font-family: 'Courier New', monospace;
            transition: all 0.3s;
            background: rgba(0, 255, 255, 0.1);
            color: #00ffff;
            text-shadow: 0 0 5px #00ffff;
        }

        #upgradePanel button:hover {
            background: rgba(0, 255, 255, 0.3);
            box-shadow: 0 0 20px #00ffff;
            transform: scale(1.05);
        }

        #upgradePanel button:disabled {
            background: rgba(100, 100, 100, 0.3);
            border-color: #666;
            color: #666;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
            text-shadow: none;
        }

        #closeBtn {
            background: rgba(255, 51, 51, 0.1);
            border-color: #ff3333;
            color: #ff3333;
            text-shadow: 0 0 5px #ff3333;
        }

        #closeBtn:hover {
            background: rgba(255, 51, 51, 0.3);
            box-shadow: 0 0 20px #ff3333;
        }

        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.85);
            padding: 15px 25px;
            border-radius: 5px;
            border: 2px solid #00ffff;
            color: #00ffff;
            text-align: center;
            display: flex;
            gap: 10px;
            align-items: center;
        }

        #controls button {
            background: rgba(0, 255, 255, 0.2);
            color: #00ffff;
            border: 2px solid #00ffff;
            padding: 10px 20px;
            border-radius: 5px;
            font-size: 16px;
            font-weight: bold;
            font-family: 'Courier New', monospace;
            cursor: pointer;
            transition: all 0.3s;
            text-shadow: 0 0 5px #00ffff;
        }

        #controls button:hover {
            background: rgba(0, 255, 255, 0.4);
            box-shadow: 0 0 20px #00ffff;
            transform: scale(1.05);
        }

        #controls button:disabled {
            background: rgba(100, 100, 100, 0.2);
            border-color: #666;
            color: #666;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
            text-shadow: none;
        }

        #controls button.active {
            background: rgba(255, 51, 51, 0.4);
            border-color: #ff3333;
            color: #ff3333;
            text-shadow: 0 0 10px #ff3333;
            box-shadow: 0 0 15px rgba(255, 51, 51, 0.5);
        }

        #speedControls {
            display: flex;
            gap: 5px;
            border-left: 2px solid rgba(0, 255, 255, 0.3);
            padding-left: 15px;
        }

        .speedBtn {
            padding: 8px 15px !important;
            font-size: 14px !important;
            min-width: 60px;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <div id="ui">
        <h2>‚ö° GALAXY TD</h2>
        <p>üí∞ <span id="gold">500</span></p>
        <p>‚ù§Ô∏è <span id="lives">20</span></p>
        <p>üåä <span id="wave">0</span></p>
        <p class="info">Build: 100g | Click to upgrade</p>
    </div>

    <div id="upgradePanel">
        <h3>‚ö° TOWER UPGRADE ‚ö°</h3>
        <div class="specialization" id="specializationInfo">
            <div class="specialization-label" id="towerSpecialization">Basic Tower</div>
        </div>
        <div class="stat">
            <span>Level:</span>
            <span id="towerLevel">1</span>
        </div>
        <div class="stat">
            <span>Range:</span>
            <span id="towerRange">3.0</span>
        </div>
        <div class="stat">
            <span>Fire Rate:</span>
            <span id="towerFireRate">1.0/s</span>
        </div>
        <div class="stat">
            <span>Damage:</span>
            <span id="towerDamage">1</span>
        </div>
        <div id="upgradeTreeSection" style="display: none;">
            <h4 style="color: #ff3333; margin-top: 20px; text-align: center; text-shadow: 0 0 10px #ff3333;">Choose Specialization</h4>
            <div class="upgrade-options">
                <div class="upgrade-option" data-type="rapidfire">
                    <h4>üî• Rapid Fire</h4>
                    <p>High fire rate</p>
                    <p>Lower damage</p>
                    <div class="cost">100g</div>
                </div>
                <div class="upgrade-option" data-type="sniper">
                    <h4>üéØ Sniper</h4>
                    <p>Long range</p>
                    <p>High damage</p>
                    <div class="cost">100g</div>
                </div>
                <div class="upgrade-option" data-type="frost">
                    <h4>‚ùÑÔ∏è Frost</h4>
                    <p>Slows enemies</p>
                    <p>Moderate damage</p>
                    <div class="cost">100g</div>
                </div>
                <div class="upgrade-option" data-type="splash">
                    <h4>üí• Splash</h4>
                    <p>Area damage</p>
                    <p>Hits multiple</p>
                    <div class="cost">100g</div>
                </div>
                <div class="upgrade-option" data-type="poison">
                    <h4>‚ò†Ô∏è Poison</h4>
                    <p>Damage over time</p>
                    <p>Stacking effect</p>
                    <div class="cost">100g</div>
                </div>
            </div>
        </div>
        <div id="upgradeStandardSection">
            <button id="upgradeBtn">‚¨ÜÔ∏è UPGRADE (150g)</button>
        </div>
        <button id="closeBtn">‚úñÔ∏è CLOSE</button>
    </div>

    <div id="confirmPanel" style="display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0, 0, 0, 0.95); padding: 30px; border-radius: 10px; border: 3px solid #00ffff; color: #00ffff; z-index: 200; min-width: 300px; text-shadow: 0 0 5px #00ffff;">
        <h3 style="margin-bottom: 20px; color: #ff3333; text-align: center; text-shadow: 0 0 15px #ff3333;">Build Tower?</h3>
        <p style="margin: 15px 0; text-align: center; font-size: 16px;">Cost: <span style="color: #ff3333; font-weight: bold; text-shadow: 0 0 5px #ff3333;">100 Gold</span></p>
        <p style="font-size: 14px; color: #888; text-align: center; margin-bottom: 20px;">Place a tower on this tile?</p>
        <div style="display: flex; gap: 10px;">
            <button id="confirmBuildBtn" style="flex: 1; padding: 12px; border: 2px solid #00ffff; border-radius: 5px; font-size: 16px; cursor: pointer; font-weight: bold; font-family: 'Courier New', monospace; transition: all 0.3s; background: rgba(0, 255, 255, 0.1); color: #00ffff; text-shadow: 0 0 5px #00ffff;">BUILD</button>
            <button id="cancelBuildBtn" style="flex: 1; padding: 12px; border: 2px solid #ff3333; border-radius: 5px; font-size: 16px; cursor: pointer; font-weight: bold; font-family: 'Courier New', monospace; transition: all 0.3s; background: rgba(255, 51, 51, 0.1); color: #ff3333; text-shadow: 0 0 5px #ff3333;">CANCEL</button>
        </div>
    </div>

    <div id="controls">
        <button id="rotateLeftBtn">‚ü≤ ROTATE</button>
        <button id="waveBtn">‚ñ∂Ô∏è START WAVE</button>
        <button id="pauseBtn">‚è∏Ô∏è PAUSE</button>
        <button id="rotateRightBtn">‚ü≥ ROTATE</button>
        <div id="speedControls">
            <button class="speedBtn" data-speed="0.5">0.5x</button>
            <button class="speedBtn active" data-speed="1">1x</button>
            <button class="speedBtn" data-speed="1.5">1.5x</button>
            <button class="speedBtn" data-speed="3">3x</button>
        </div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
            "tone": "https://cdn.skypack.dev/tone@15.1.22"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
        import * as Tone from 'tone';

        // ============================================
        // GAME CONFIGURATION
        // ============================================
        const CONFIG = {
            GRID_SIZE: 10,
            TILE_SIZE: 1,
            TOWER_COST: 100,
            INITIAL_GOLD: 350,
            INITIAL_LIVES: 15,
            ELEVATION_HEIGHT: 0.5
        };

        // ============================================
        // SOUND SYSTEM
        // ============================================
        class SoundSystem {
            constructor() {
                this.enabled = false;
                this.initialized = false;
            }

            async init() {
                if (this.initialized) return;
                try {
                    await Tone.start();
                    this.initialized = true;
                    this.enabled = true;
                    console.log('üîä Sound system initialized');
                } catch (error) {
                    console.error('Failed to initialize sound:', error);
                }
            }

            playShoot(towerType = 'basic') {
                if (!this.enabled) return;
                try {
                    if (towerType === 'sniper') {
                        // Swift energy beam - frequency sweep
                        const synth = new Tone.Synth({
                            oscillator: { type: 'sine' },
                            envelope: { attack: 0.001, decay: 0.08, sustain: 0, release: 0.05 }
                        }).toDestination();
                        synth.frequency.rampTo('G6', 0.03);
                        synth.triggerAttackRelease('C7', '0.08');
                        setTimeout(() => synth.dispose(), 200);
                    } else if (towerType === 'poison') {
                        // Bubbly toxic sound
                        const synth = new Tone.Synth({
                            oscillator: { type: 'triangle' },
                            envelope: { attack: 0.01, decay: 0.15, sustain: 0.1, release: 0.15 }
                        }).toDestination();
                        synth.triggerAttackRelease('E3', '0.12');
                        setTimeout(() => {
                            synth.triggerAttackRelease('G3', '0.05');
                        }, 60);
                        setTimeout(() => synth.dispose(), 300);
                    } else if (towerType === 'splash') {
                        // Burst explosion sound
                        const synth = new Tone.NoiseSynth({
                            noise: { type: 'pink' },
                            envelope: { attack: 0.001, decay: 0.1, sustain: 0, release: 0.1 }
                        }).toDestination();
                        synth.triggerAttackRelease('0.06');
                        setTimeout(() => synth.dispose(), 200);
                    } else if (towerType === 'frost') {
                        // Crystalline icy sound
                        const synth = new Tone.Synth({
                            oscillator: { type: 'sine' },
                            envelope: { attack: 0.001, decay: 0.2, sustain: 0.1, release: 0.3 }
                        }).toDestination();
                        synth.triggerAttackRelease('E6', '0.15');
                        setTimeout(() => {
                            synth.triggerAttackRelease('G#6', '0.08');
                        }, 40);
                        setTimeout(() => synth.dispose(), 500);
                    } else if (towerType === 'rapidfire') {
                        // Quick rapid fire blip
                        const synth = new Tone.Synth({
                            oscillator: { type: 'square' },
                            envelope: { attack: 0.001, decay: 0.05, sustain: 0, release: 0.05 }
                        }).toDestination();
                        synth.triggerAttackRelease('A5', '0.03');
                        setTimeout(() => synth.dispose(), 150);
                    } else {
                        // Basic tower sound
                        const synth = new Tone.Synth({
                            oscillator: { type: 'sine' },
                            envelope: { attack: 0.001, decay: 0.1, sustain: 0, release: 0.1 }
                        }).toDestination();
                        synth.triggerAttackRelease('C6', '0.05');
                        setTimeout(() => synth.dispose(), 200);
                    }
                } catch (e) { console.error('Sound error:', e); }
            }

            playEnemyDeath() {
                if (!this.enabled) return;
                try {
                    const synth = new Tone.Synth({
                        oscillator: { type: 'square' },
                        envelope: { attack: 0.001, decay: 0.2, sustain: 0, release: 0.2 }
                    }).toDestination();
                    synth.triggerAttackRelease('A2', '0.15');
                    setTimeout(() => synth.dispose(), 500);
                } catch (e) { console.error('Sound error:', e); }
            }

            playTowerPlace() {
                if (!this.enabled) return;
                try {
                    const synth = new Tone.Synth({
                        oscillator: { type: 'triangle' },
                        envelope: { attack: 0.001, decay: 0.1, sustain: 0.3, release: 0.1 }
                    }).toDestination();
                    synth.triggerAttackRelease('G5', '0.1');
                    setTimeout(() => synth.dispose(), 300);
                } catch (e) { console.error('Sound error:', e); }
            }

            playUpgrade() {
                if (!this.enabled) return;
                try {
                    const synth = new Tone.Synth({
                        oscillator: { type: 'sine' },
                        envelope: { attack: 0.005, decay: 0.1, sustain: 0.2, release: 0.2 }
                    }).toDestination();
                    synth.triggerAttackRelease('C6', '0.05');
                    setTimeout(() => {
                        synth.triggerAttackRelease('E6', '0.05');
                    }, 50);
                    setTimeout(() => synth.dispose(), 400);
                } catch (e) { console.error('Sound error:', e); }
            }

            playWaveComplete() {
                if (!this.enabled) return;
                try {
                    const synth = new Tone.PolySynth(Tone.Synth).toDestination();
                    synth.triggerAttackRelease(['C5', 'E5', 'G5'], '0.2');
                    setTimeout(() => synth.dispose(), 500);
                } catch (e) { console.error('Sound error:', e); }
            }

            playGameOver() {
                if (!this.enabled) return;
                try {
                    const synth = new Tone.Synth({
                        oscillator: { type: 'sawtooth' },
                        envelope: { attack: 0.01, decay: 0.5, sustain: 0, release: 0.5 }
                    }).toDestination();
                    synth.triggerAttackRelease('E3', '0.8');
                    setTimeout(() => synth.dispose(), 1500);
                } catch (e) { console.error('Sound error:', e); }
            }
        }

        const soundSystem = new SoundSystem();

        // ============================================
        // SCANLINES SHADER
        // ============================================
        const ScanlinesShader = {
            uniforms: {
                'tDiffuse': { value: null },
                'time': { value: 0 },
                'intensity': { value: 0.15 }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform sampler2D tDiffuse;
                uniform float time;
                uniform float intensity;
                varying vec2 vUv;

                void main() {
                    vec4 color = texture2D(tDiffuse, vUv);

                    // Slow moving scanlines
                    float scanline = sin((vUv.y + time * 0.02) * 300.0) * 0.5 + 0.5;
                    scanline = pow(scanline, 3.0) * intensity;

                    color.rgb -= scanline;

                    gl_FragColor = color;
                }
            `
        };

        // ============================================
        // PATH DEFINITION - Winding glass path
        // ============================================
        const PATH = [
            {x: 0, z: 1}, {x: 1, z: 1}, {x: 2, z: 1}, {x: 3, z: 1},
            {x: 3, z: 2}, {x: 3, z: 3}, {x: 3, z: 4},
            {x: 2, z: 4}, {x: 1, z: 4},
            {x: 1, z: 5}, {x: 1, z: 6}, {x: 1, z: 7},
            {x: 2, z: 7}, {x: 3, z: 7}, {x: 4, z: 7}, {x: 5, z: 7},
            {x: 5, z: 6}, {x: 5, z: 5},
            {x: 6, z: 5}, {x: 7, z: 5}, {x: 8, z: 5},
            {x: 8, z: 6}, {x: 8, z: 7}, {x: 8, z: 8},
            {x: 9, z: 8}
        ];

        // ============================================
        // PROCEDURAL GLITCH ENEMY CLASS
        // ============================================
        class Enemy {
            constructor(scene, path, wave) {
                this.scene = scene;
                this.path = path;
                this.pathIndex = 0;
                this.wave = wave;

                // Balanced difficulty for late game
                if (wave === 1) {
                    this.health = 3;
                } else if (wave === 2) {
                    this.health = 5;
                } else if (wave <= 5) {
                    this.health = 5 + wave * 2.5;
                } else {
                    // Exponential health scaling for late game
                    this.health = Math.floor(12 + wave * 3.5 + (wave - 5) * 1.5);
                }

                this.maxHealth = this.health;
                this.baseSpeed = 0.018 + (wave * 0.003);
                this.speed = this.baseSpeed;
                this.reward = 2 + Math.floor(wave * 0.7);
                this.alive = true;
                this.slowUntil = 0;
                this.poisonStacks = [];

                // Create Glitch Enemy with jagged shards
                this.createGlitchMesh();

                // Start at first path position
                const startPos = this.path[0];
                this.mesh.position.set(
                    startPos.x - CONFIG.GRID_SIZE/2 + 0.5,
                    0.4,
                    startPos.z - CONFIG.GRID_SIZE/2 + 0.5
                );

                this.scene.add(this.mesh);
                this.rotationSpeed = 0.02;
            }

            createGlitchMesh() {
                // Create IcosahedronGeometry with vertex jittering
                const geometry = new THREE.IcosahedronGeometry(0.35, 0);
                const positions = geometry.attributes.position;

                // Jitter vertices to create jagged glitch effect
                for (let i = 0; i < positions.count; i++) {
                    const vertex = new THREE.Vector3();
                    vertex.fromBufferAttribute(positions, i);

                    // Random jitter
                    vertex.x += (Math.random() - 0.5) * 0.15;
                    vertex.y += (Math.random() - 0.5) * 0.15;
                    vertex.z += (Math.random() - 0.5) * 0.15;

                    positions.setXYZ(i, vertex.x, vertex.y, vertex.z);
                }

                geometry.computeVertexNormals();

                // Neon glowing material
                const hue = (this.wave * 0.1) % 1;
                const material = new THREE.MeshStandardMaterial({
                    color: new THREE.Color().setHSL(hue, 1, 0.5),
                    emissive: new THREE.Color().setHSL(hue, 1, 0.4),
                    emissiveIntensity: 2,
                    metalness: 0.8,
                    roughness: 0.2,
                    wireframe: false
                });

                this.mesh = new THREE.Mesh(geometry, material);
            }

            applySlow(amount, duration) {
                this.slowUntil = Math.max(this.slowUntil, Date.now() + duration);
                this.speed = this.baseSpeed * (1 - amount);
            }

            applyPoison(damage, duration) {
                this.poisonStacks.push({
                    damage: damage,
                    endTime: Date.now() + duration,
                    lastTick: Date.now()
                });
            }

            takeDamage(amount) {
                this.health -= amount;

                if (this.health <= 0) {
                    this.alive = false;
                    this.die();
                    return true;
                }
                return false;
            }

            die() {
                soundSystem.playEnemyDeath();
                // Shrink and fade effect
                const fadeOut = () => {
                    this.mesh.scale.multiplyScalar(0.9);
                    this.mesh.material.opacity -= 0.1;
                    this.mesh.material.transparent = true;

                    if (this.mesh.material.opacity > 0) {
                        requestAnimationFrame(fadeOut);
                    }
                };
                fadeOut();
            }

            update(gameSpeed = 1) {
                if (!this.alive) return false;

                // Update slow effect
                if (Date.now() > this.slowUntil) {
                    this.speed = this.baseSpeed;
                }

                // Update poison effects
                const currentTime = Date.now();
                for (let i = this.poisonStacks.length - 1; i >= 0; i--) {
                    const poison = this.poisonStacks[i];
                    if (currentTime > poison.endTime) {
                        this.poisonStacks.splice(i, 1);
                    } else if (currentTime - poison.lastTick >= 500) {
                        poison.lastTick = currentTime;
                        this.takeDamage(poison.damage);
                    }
                }

                // Rotate for digital glitch effect - affected by game speed
                this.mesh.rotation.x += this.rotationSpeed * gameSpeed;
                this.mesh.rotation.y += this.rotationSpeed * 1.5 * gameSpeed;

                const currentTarget = this.path[this.pathIndex];
                const targetWorldPos = new THREE.Vector3(
                    currentTarget.x - CONFIG.GRID_SIZE/2 + 0.5,
                    0.4,
                    currentTarget.z - CONFIG.GRID_SIZE/2 + 0.5
                );

                const direction = targetWorldPos.clone().sub(this.mesh.position);
                const distance = direction.length();

                if (distance < 0.1) {
                    this.pathIndex++;
                    if (this.pathIndex >= this.path.length) {
                        this.alive = false;
                        return 'escaped';
                    }
                } else {
                    direction.normalize();
                    // Apply game speed to movement
                    this.mesh.position.add(direction.multiplyScalar(this.speed * gameSpeed));
                }

                return true;
            }

            destroy() {
                this.scene.remove(this.mesh);
                this.mesh.geometry.dispose();
                this.mesh.material.dispose();
            }
        }

        // ============================================
        // PROCEDURAL MONOLITH TOWER CLASS
        // ============================================
        class Tower {
            constructor(scene, gridX, gridZ) {
                this.scene = scene;
                this.gridX = gridX;
                this.gridZ = gridZ;
                this.level = 1;
                this.range = 2.5;
                this.fireRate = 0.8;
                this.damage = 1;
                this.lastFireTime = 0;
                this.upgradeCost = 150;
                this.specialization = null;
                this.maxLevel = null;

                // Specialization stats
                this.slowAmount = 0;
                this.slowDuration = 0;
                this.poisonDamage = 0;
                this.poisonDuration = 0;
                this.splashRadius = 0;

                // Animation properties
                this.time = Math.random() * Math.PI * 2;
                this.hoverSpeed = 1.5;
                this.hoverAmplitude = 0.15;
                this.baseY = CONFIG.ELEVATION_HEIGHT + 0.5;

                // Toy lunge properties
                this.isLunging = false;
                this.lungeTarget = null;
                this.originalPosition = new THREE.Vector3();

                // Create tower group
                this.group = new THREE.Group();
                this.createTowerGeometry(this.level);

                const worldPos = this.gridToWorld(gridX, gridZ);
                this.group.position.set(worldPos.x, this.baseY, worldPos.z);
                this.originalPosition.copy(this.group.position);

                this.scene.add(this.group);
            }

            createTowerGeometry(level) {
                // Clear existing geometry
                while(this.group.children.length > 0) {
                    const child = this.group.children[0];
                    this.group.remove(child);
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) child.material.dispose();
                }

                // Determine color based on specialization
                let towerColor = 0x00ffff;
                let emissiveColor = 0x00ffff;

                if (this.specialization) {
                    switch(this.specialization) {
                        case 'rapidfire':
                            towerColor = 0xff0000;
                            emissiveColor = 0xff0000;
                            break;
                        case 'sniper':
                            towerColor = 0xff0000;
                            emissiveColor = 0xff0000;
                            break;
                        case 'frost':
                            towerColor = 0xff0000;
                            emissiveColor = 0xff0000;
                            break;
                        case 'splash':
                            towerColor = 0xff0000;
                            emissiveColor = 0xff0000;
                            break;
                        case 'poison':
                            towerColor = 0xff0000;
                            emissiveColor = 0xff0000;
                            break;
                    }
                }

                // PEDESTAL - smaller size
                const pedestalGeo = new THREE.BoxGeometry(0.7, 0.15, 0.7);
                pedestalGeo.computeBoundingBox();

                const pedestalMat = new THREE.MeshStandardMaterial({
                    color: towerColor,
                    emissive: emissiveColor,
                    emissiveIntensity: 0.5,
                    metalness: 0.7,
                    roughness: 0.3,
                    // Ready for texture: map: textureLoader.load('your-pattern.jpg')
                });

                this.pedestal = new THREE.Mesh(pedestalGeo, pedestalMat);
                this.pedestal.position.y = -0.5;
                this.group.add(this.pedestal);

                // Add glowing border to pedestal
                const borderGeo = new THREE.EdgesGeometry(pedestalGeo);
                const borderMat = new THREE.LineBasicMaterial({
                    color: towerColor,
                    linewidth: 2
                });
                const border = new THREE.LineSegments(borderGeo, borderMat);
                this.pedestal.add(border);

                // Create tesseract-like structure based on specialization
                if (!this.specialization) {
                    this.createBasicTesseract(towerColor, emissiveColor, level);
                } else {
                    switch(this.specialization) {
                        case 'rapidfire':
                            this.createRapidFireTesseract(towerColor, emissiveColor, level);
                            break;
                        case 'sniper':
                            this.createSniperTesseract(towerColor, emissiveColor, level);
                            break;
                        case 'frost':
                            this.createFrostTesseract(towerColor, emissiveColor, level);
                            break;
                        case 'splash':
                            this.createSplashTesseract(towerColor, emissiveColor, level);
                            break;
                        case 'poison':
                            this.createPoisonTesseract(towerColor, emissiveColor, level);
                            break;
                    }
                }

                // Add range indicator
                this.createRangeIndicator();
            }

            createBasicTesseract(towerColor, emissiveColor, level) {
                // Orbiting octahedrons around center
                this.orbitingCubes = [];
                const count = 3;
                const radius = 0.25;
                const cubeSize = 0.09;

                for (let i = 0; i < count; i++) {
                    const angle = (i / count) * Math.PI * 2;
                    const cubeGeo = new THREE.OctahedronGeometry(cubeSize);
                    const cubeMat = new THREE.MeshStandardMaterial({
                        color: towerColor,
                        emissive: emissiveColor,
                        emissiveIntensity: 1.5,
                        metalness: 0.9,
                        roughness: 0.1
                    });
                    const cube = new THREE.Mesh(cubeGeo, cubeMat);

                    cube.userData.angle = angle;
                    cube.userData.radius = radius;
                    cube.position.x = Math.cos(angle) * radius;
                    cube.position.y = 0.3;
                    cube.position.z = Math.sin(angle) * radius;

                    this.group.add(cube);
                    this.orbitingCubes.push(cube);
                }

                // Central core cube
                const coreGeo = new THREE.BoxGeometry(0.15, 0.15, 0.15);
                const coreMat = new THREE.MeshStandardMaterial({
                    color: towerColor,
                    emissive: emissiveColor,
                    emissiveIntensity: 2,
                    metalness: 1,
                    roughness: 0
                });
                this.towerCore = new THREE.Mesh(coreGeo, coreMat);
                this.towerCore.position.y = 0.3;

                const coreWireGeo = new THREE.EdgesGeometry(coreGeo);
                const coreWireMat = new THREE.LineBasicMaterial({ color: towerColor, linewidth: 3 });
                const coreWire = new THREE.LineSegments(coreWireGeo, coreWireMat);
                this.towerCore.add(coreWire);

                this.group.add(this.towerCore);
            }

            createRapidFireTesseract(towerColor, emissiveColor, level) {
                // Multiple small cubes orbiting center
                this.orbitingCubes = [];
                const count = 4;
                const radius = 0.28;
                const cubeSize = 0.11;

                for (let i = 0; i < count; i++) {
                    const angle = (i / count) * Math.PI * 2;
                    const cubeGeo = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);
                    const cubeMat = new THREE.MeshStandardMaterial({
                        color: towerColor,
                        emissive: emissiveColor,
                        emissiveIntensity: 1.5,
                        metalness: 0.9,
                        roughness: 0.1
                    });
                    const cube = new THREE.Mesh(cubeGeo, cubeMat);

                    cube.userData.angle = angle;
                    cube.userData.radius = radius;
                    cube.position.x = Math.cos(angle) * radius;
                    cube.position.y = 0.3;
                    cube.position.z = Math.sin(angle) * radius;

                    this.group.add(cube);
                    this.orbitingCubes.push(cube);
                }

                // Central core
                const coreGeo = new THREE.OctahedronGeometry(0.15);
                const coreMat = new THREE.MeshStandardMaterial({
                    color: towerColor,
                    emissive: emissiveColor,
                    emissiveIntensity: 2,
                    metalness: 1,
                    roughness: 0
                });
                this.towerCore = new THREE.Mesh(coreGeo, coreMat);
                this.towerCore.position.y = 0.3;
                this.group.add(this.towerCore);
            }

            createSniperTesseract(towerColor, emissiveColor, level) {
                // Orbiting elongated diamonds around vertical core
                this.orbitingCubes = [];
                const count = 3;
                const radius = 0.28;

                for (let i = 0; i < count; i++) {
                    const angle = (i / count) * Math.PI * 2;
                    // Elongated diamond shape
                    const cubeGeo = new THREE.OctahedronGeometry(0.06);
                    cubeGeo.scale(0.5, 2, 0.5);

                    const cubeMat = new THREE.MeshStandardMaterial({
                        color: towerColor,
                        emissive: emissiveColor,
                        emissiveIntensity: 1.8,
                        metalness: 1,
                        roughness: 0
                    });
                    const cube = new THREE.Mesh(cubeGeo, cubeMat);

                    // Add wireframe
                    const wireGeo = new THREE.EdgesGeometry(cubeGeo);
                    const wireMat = new THREE.LineBasicMaterial({ color: towerColor, linewidth: 2 });
                    const wire = new THREE.LineSegments(wireGeo, wireMat);
                    cube.add(wire);

                    cube.userData.angle = angle;
                    cube.userData.radius = radius;
                    cube.position.x = Math.cos(angle) * radius;
                    cube.position.y = 0.5;
                    cube.position.z = Math.sin(angle) * radius;

                    this.group.add(cube);
                    this.orbitingCubes.push(cube);
                }

                // Central tall crystal
                const coreGeo = new THREE.CylinderGeometry(0.06, 0.06, 0.6, 8);
                const coreMat = new THREE.MeshStandardMaterial({
                    color: towerColor,
                    emissive: emissiveColor,
                    emissiveIntensity: 2.5,
                    metalness: 1,
                    roughness: 0
                });
                this.towerCore = new THREE.Mesh(coreGeo, coreMat);
                this.towerCore.position.y = 0.5;

                const coreWireGeo = new THREE.EdgesGeometry(coreGeo);
                const coreWireMat = new THREE.LineBasicMaterial({ color: towerColor, linewidth: 3 });
                const coreWire = new THREE.LineSegments(coreWireGeo, coreWireMat);
                this.towerCore.add(coreWire);

                this.group.add(this.towerCore);
            }

            createFrostTesseract(towerColor, emissiveColor, level) {
                // Orbiting ice crystals around frozen core
                this.orbitingCubes = [];
                const count = 4;
                const radius = 0.27;

                for (let i = 0; i < count; i++) {
                    const angle = (i / count) * Math.PI * 2;
                    // Ice crystal shape
                    const cubeGeo = new THREE.ConeGeometry(0.045, 0.18, 6);
                    const cubeMat = new THREE.MeshStandardMaterial({
                        color: towerColor,
                        emissive: emissiveColor,
                        emissiveIntensity: 1.8,
                        metalness: 1,
                        roughness: 0,
                        transparent: true,
                        opacity: 0.9
                    });
                    const cube = new THREE.Mesh(cubeGeo, cubeMat);

                    // Add wireframe
                    const wireGeo = new THREE.EdgesGeometry(cubeGeo);
                    const wireMat = new THREE.LineBasicMaterial({ color: towerColor, linewidth: 2 });
                    const wire = new THREE.LineSegments(wireGeo, wireMat);
                    cube.add(wire);

                    cube.userData.angle = angle;
                    cube.userData.radius = radius;
                    cube.userData.verticalOffset = Math.sin(angle * 3) * 0.15; // Varied height
                    cube.position.x = Math.cos(angle) * radius;
                    cube.position.y = 0.4 + cube.userData.verticalOffset;
                    cube.position.z = Math.sin(angle) * radius;
                    cube.rotation.z = Math.PI; // Point down initially

                    this.group.add(cube);
                    this.orbitingCubes.push(cube);
                }

                // Central frozen octahedron
                const coreGeo = new THREE.OctahedronGeometry(0.13);
                const coreMat = new THREE.MeshStandardMaterial({
                    color: towerColor,
                    emissive: emissiveColor,
                    emissiveIntensity: 2.2,
                    metalness: 1,
                    roughness: 0,
                    transparent: true,
                    opacity: 0.8
                });
                this.towerCore = new THREE.Mesh(coreGeo, coreMat);
                this.towerCore.position.y = 0.4;

                const coreWireGeo = new THREE.EdgesGeometry(coreGeo);
                const coreWireMat = new THREE.LineBasicMaterial({ color: towerColor, linewidth: 3 });
                const coreWire = new THREE.LineSegments(coreWireGeo, coreWireMat);
                this.towerCore.add(coreWire);

                this.group.add(this.towerCore);
            }

            createSplashTesseract(towerColor, emissiveColor, level) {
                // Orbiting explosive shards around core
                this.orbitingCubes = [];
                const count = 4;
                const radius = 0.29;

                for (let i = 0; i < count; i++) {
                    const angle = (i / count) * Math.PI * 2;
                    // Jagged shard shape
                    const cubeGeo = new THREE.TetrahedronGeometry(0.09);
                    const cubeMat = new THREE.MeshStandardMaterial({
                        color: towerColor,
                        emissive: emissiveColor,
                        emissiveIntensity: 1.7,
                        metalness: 0.9,
                        roughness: 0.1
                    });
                    const cube = new THREE.Mesh(cubeGeo, cubeMat);

                    cube.userData.angle = angle;
                    cube.userData.radius = radius;
                    cube.userData.pulsePhase = i * 0.5;
                    cube.position.x = Math.cos(angle) * radius;
                    cube.position.y = 0.35;
                    cube.position.z = Math.sin(angle) * radius;

                    this.group.add(cube);
                    this.orbitingCubes.push(cube);
                }

                // Central explosive core - dodecahedron
                const coreGeo = new THREE.DodecahedronGeometry(0.12);
                const coreMat = new THREE.MeshStandardMaterial({
                    color: towerColor,
                    emissive: emissiveColor,
                    emissiveIntensity: 2.2,
                    metalness: 1,
                    roughness: 0
                });
                this.towerCore = new THREE.Mesh(coreGeo, coreMat);
                this.towerCore.position.y = 0.35;
                this.pulsePhase = 0;

                const coreWireGeo = new THREE.EdgesGeometry(coreGeo);
                const coreWireMat = new THREE.LineBasicMaterial({ color: towerColor, linewidth: 3 });
                const coreWire = new THREE.LineSegments(coreWireGeo, coreWireMat);
                this.towerCore.add(coreWire);

                this.group.add(this.towerCore);
            }

            createPoisonTesseract(towerColor, emissiveColor, level) {
                // Orbiting toxic orbs around poisonous core
                this.orbitingCubes = [];
                const count = 3;
                const radius = 0.25;

                for (let i = 0; i < count; i++) {
                    const angle = (i / count) * Math.PI * 2;
                    // Toxic orb with jagged exterior
                    const cubeGeo = new THREE.IcosahedronGeometry(0.07);
                    const cubeMat = new THREE.MeshStandardMaterial({
                        color: towerColor,
                        emissive: emissiveColor,
                        emissiveIntensity: 1.9,
                        metalness: 0.8,
                        roughness: 0.2,
                        transparent: true,
                        opacity: 0.85
                    });
                    const cube = new THREE.Mesh(cubeGeo, cubeMat);

                    cube.userData.angle = angle;
                    cube.userData.radius = radius;
                    cube.userData.spiralPhase = i * 0.3;
                    cube.position.x = Math.cos(angle) * radius;
                    cube.position.y = 0.4;
                    cube.position.z = Math.sin(angle) * radius;

                    this.group.add(cube);
                    this.orbitingCubes.push(cube);
                }

                // Central toxic sphere
                const coreGeo = new THREE.SphereGeometry(0.11, 8, 8);
                const coreMat = new THREE.MeshStandardMaterial({
                    color: towerColor,
                    emissive: emissiveColor,
                    emissiveIntensity: 2.5,
                    metalness: 0.7,
                    roughness: 0.3,
                    transparent: true,
                    opacity: 0.7
                });
                this.towerCore = new THREE.Mesh(coreGeo, coreMat);
                this.towerCore.position.y = 0.4;

                const coreWireGeo = new THREE.EdgesGeometry(coreGeo);
                const coreWireMat = new THREE.LineBasicMaterial({ color: towerColor, linewidth: 3 });
                const coreWire = new THREE.LineSegments(coreWireGeo, coreWireMat);
                this.towerCore.add(coreWire);

                this.group.add(this.towerCore);
            }

            createRangeIndicator() {
                const geometry = new THREE.RingGeometry(this.range - 0.1, this.range, 32);
                const material = new THREE.MeshBasicMaterial({
                    color: this.getColorForSpecialization(),
                    transparent: true,
                    opacity: 0.15,
                    side: THREE.DoubleSide
                });
                this.rangeIndicator = new THREE.Mesh(geometry, material);
                this.rangeIndicator.rotation.x = -Math.PI / 2;
                this.rangeIndicator.position.y = -this.baseY + 0.1;
                this.group.add(this.rangeIndicator);
                this.rangeIndicator.visible = false;
            }

            getColorForSpecialization() {
                if (!this.specialization) return 0x00ffff;
                return 0xff0000;
            }

            gridToWorld(x, z) {
                return {
                    x: x - CONFIG.GRID_SIZE/2 + 0.5,
                    z: z - CONFIG.GRID_SIZE/2 + 0.5
                };
            }

            specialize(type) {
                this.specialization = type;
                this.level = 2;
                this.upgradeCost = 150;
                this.maxLevel = 5;

                switch(type) {
                    case 'rapidfire':
                        this.fireRate = 2.5;
                        this.damage = 0.8;
                        this.range = 2.2;
                        break;
                    case 'sniper':
                        this.fireRate = 0.4;
                        this.damage = 3;
                        this.range = 4.5;
                        break;
                    case 'frost':
                        this.fireRate = 1.0;
                        this.damage = 0.8;
                        this.range = 3.0;
                        this.slowAmount = 0.4;
                        this.slowDuration = 1800;
                        break;
                    case 'splash':
                        this.fireRate = 0.7;
                        this.damage = 1.5;
                        this.range = 3.0;
                        this.splashRadius = 1.3;
                        break;
                    case 'poison':
                        this.fireRate = 0.9;
                        this.damage = 0.8;
                        this.range = 2.8;
                        this.poisonDamage = 0.4;
                        this.poisonDuration = 2500;
                        break;
                }

                // Rebuild geometry with specialization color
                this.createTowerGeometry(this.level);

                // Update range indicator
                if (this.rangeIndicator) {
                    this.rangeIndicator.geometry.dispose();
                    const geometry = new THREE.RingGeometry(this.range - 0.1, this.range, 32);
                    this.rangeIndicator.geometry = geometry;
                    this.rangeIndicator.material.color.setHex(this.getColorForSpecialization());
                }
            }

            upgrade() {
                // Check if at max level
                if (this.maxLevel && this.level >= this.maxLevel) {
                    return false;
                }

                this.level++;

                // Scale upgrade cost: 150 -> 250 -> 400 -> 650
                this.upgradeCost = Math.floor(this.upgradeCost * 1.7);

                if (!this.specialization) {
                    // Basic tower upgrade
                    this.range += 0.3;
                    this.fireRate += 0.2;
                    this.damage += 0.5;
                } else {
                    // Specialized tower upgrade
                    switch(this.specialization) {
                        case 'rapidfire':
                            this.fireRate += 0.5;
                            this.damage += 0.3;
                            break;
                        case 'sniper':
                            this.damage += 1.5;
                            this.range += 0.3;
                            break;
                        case 'frost':
                            this.slowAmount = Math.min(0.7, this.slowAmount + 0.08);
                            this.slowDuration += 400;
                            this.damage += 0.3;
                            break;
                        case 'splash':
                            this.damage += 0.6;
                            this.splashRadius += 0.2;
                            break;
                        case 'poison':
                            this.poisonDamage += 0.2;
                            this.poisonDuration += 400;
                            this.damage += 0.3;
                            break;
                    }
                }

                // Rebuild geometry with new level
                this.createTowerGeometry(this.level);

                // Update range indicator
                if (this.rangeIndicator) {
                    this.rangeIndicator.geometry.dispose();
                    const geometry = new THREE.RingGeometry(this.range - 0.1, this.range, 32);
                    this.rangeIndicator.geometry = geometry;
                }

                return true;
            }

            findTarget(enemies) {
                let furthestEnemy = null;
                let maxDistance = 0;

                for (const enemy of enemies) {
                    if (!enemy.alive) continue;

                    const distance = this.group.position.distanceTo(enemy.mesh.position);
                    if (distance <= this.range && enemy.pathIndex > maxDistance) {
                        maxDistance = enemy.pathIndex;
                        furthestEnemy = enemy;
                    }
                }

                return furthestEnemy;
            }

            toyLunge(target) {
                // Store target for lunge animation
                this.lungeTarget = target.mesh.position.clone();

                // Calculate lunge direction
                const direction = this.lungeTarget.clone().sub(this.group.position).normalize();
                direction.y = 0; // Keep vertical position

                // Lunge 0.15 units toward target
                const lungePos = this.group.position.clone().add(direction.multiplyScalar(0.15));
                this.group.position.copy(lungePos);

                // Snap back immediately (next frame)
                setTimeout(() => {
                    this.group.position.copy(this.originalPosition);
                }, 16);
            }

            shoot(target, currentTime, enemies, gameSpeed = 1) {
                const timeSinceLastShot = (currentTime - this.lastFireTime) / 1000;
                // Adjust fire rate threshold by game speed
                if (timeSinceLastShot < (1 / this.fireRate) / gameSpeed) return null;

                this.lastFireTime = currentTime;

                // TOY LUNGE MECHANIC
                this.toyLunge(target);

                // Apply damage
                target.takeDamage(this.damage);
                soundSystem.playShoot(this.specialization || 'basic');

                // Apply special effects
                if (this.specialization === 'frost') {
                    target.applySlow(this.slowAmount, this.slowDuration);
                }

                if (this.specialization === 'poison') {
                    target.applyPoison(this.poisonDamage, this.poisonDuration);
                }

                if (this.specialization === 'splash' && this.splashRadius > 0) {
                    // Deal splash damage to nearby enemies
                    for (const enemy of enemies) {
                        if (enemy === target || !enemy.alive) continue;
                        const distance = target.mesh.position.distanceTo(enemy.mesh.position);
                        if (distance <= this.splashRadius) {
                            enemy.takeDamage(this.damage * 0.5);
                        }
                    }
                }

                // Return shot data for projectile
                return {
                    from: this.group.position.clone(),
                    to: target.mesh.position.clone(),
                    specialization: this.specialization
                };
            }

            showRange(visible) {
                if (this.rangeIndicator) {
                    this.rangeIndicator.visible = visible;
                }
            }

            update(enemies, currentTime, deltaTime, gameSpeed = 1) {
                // Sine-wave hover effect
                this.time += deltaTime * this.hoverSpeed;
                const hover = Math.sin(this.time) * this.hoverAmplitude;
                this.group.position.y = this.baseY + hover;

                // Update original position for lunge
                this.originalPosition.y = this.baseY + hover;

                // Animate tesseract structures based on type
                if (!this.specialization) {
                    // Basic - orbit octahedrons
                    if (this.orbitingCubes) {
                        this.orbitingCubes.forEach(cube => {
                            cube.userData.angle += deltaTime * 2;
                            cube.position.x = Math.cos(cube.userData.angle) * cube.userData.radius;
                            cube.position.z = Math.sin(cube.userData.angle) * cube.userData.radius;
                            cube.rotation.x += deltaTime * 3;
                            cube.rotation.y += deltaTime * 3;
                        });
                    }
                    if (this.towerCore) {
                        this.towerCore.rotation.x += deltaTime * 1.5;
                        this.towerCore.rotation.y += deltaTime * 2;
                    }
                } else if (this.specialization === 'rapidfire') {
                    // Rapid fire - fast orbit cubes
                    if (this.orbitingCubes) {
                        this.orbitingCubes.forEach(cube => {
                            cube.userData.angle += deltaTime * 4;
                            cube.position.x = Math.cos(cube.userData.angle) * cube.userData.radius;
                            cube.position.z = Math.sin(cube.userData.angle) * cube.userData.radius;
                            cube.rotation.x += deltaTime * 5;
                            cube.rotation.y += deltaTime * 5;
                        });
                    }
                    if (this.towerCore) {
                        this.towerCore.rotation.x += deltaTime * 3;
                        this.towerCore.rotation.y += deltaTime * 4;
                    }
                } else if (this.specialization === 'sniper') {
                    // Sniper - slower precise orbit
                    if (this.orbitingCubes) {
                        this.orbitingCubes.forEach(cube => {
                            cube.userData.angle += deltaTime * 1.5;
                            cube.position.x = Math.cos(cube.userData.angle) * cube.userData.radius;
                            cube.position.z = Math.sin(cube.userData.angle) * cube.userData.radius;
                            cube.rotation.y += deltaTime * 2;
                        });
                    }
                    if (this.towerCore) {
                        this.towerCore.rotation.y += deltaTime * 1;
                    }
                } else if (this.specialization === 'frost') {
                    // Frost - orbit crystals with vertical bobbing
                    if (this.orbitingCubes) {
                        this.orbitingCubes.forEach(cube => {
                            cube.userData.angle += deltaTime * 1.8;
                            cube.position.x = Math.cos(cube.userData.angle) * cube.userData.radius;
                            cube.position.z = Math.sin(cube.userData.angle) * cube.userData.radius;
                            // Bobbing effect
                            const bob = Math.sin(this.time * 2 + cube.userData.angle) * 0.08;
                            cube.position.y = 0.4 + cube.userData.verticalOffset + bob;
                            cube.rotation.x += deltaTime * 2;
                        });
                    }
                    if (this.towerCore) {
                        this.towerCore.rotation.x += deltaTime * 0.5;
                        this.towerCore.rotation.y += deltaTime * 0.8;
                        // Pulse scale
                        const pulse = Math.sin(this.time * 2) * 0.1 + 1;
                        this.towerCore.scale.set(pulse, pulse, pulse);
                    }
                } else if (this.specialization === 'splash') {
                    // Splash - chaotic orbit with pulsing
                    if (this.orbitingCubes) {
                        this.pulsePhase += deltaTime * 2;
                        this.orbitingCubes.forEach((cube, index) => {
                            cube.userData.angle += deltaTime * 2.5;
                            const pulse = Math.sin(this.pulsePhase + cube.userData.pulsePhase) * 0.1 + 1;
                            const radiusPulse = cube.userData.radius * pulse;
                            cube.position.x = Math.cos(cube.userData.angle) * radiusPulse;
                            cube.position.z = Math.sin(cube.userData.angle) * radiusPulse;
                            cube.rotation.x += deltaTime * 4;
                            cube.rotation.y += deltaTime * 3;
                            cube.rotation.z += deltaTime * 2;
                        });
                    }
                    if (this.towerCore) {
                        this.towerCore.rotation.x += deltaTime * 2;
                        this.towerCore.rotation.y += deltaTime * 2;
                        const pulse = Math.sin(this.pulsePhase) * 0.15 + 1;
                        this.towerCore.scale.set(pulse, pulse, pulse);
                    }
                } else if (this.specialization === 'poison') {
                    // Poison - orbit with spiral motion
                    if (this.orbitingCubes) {
                        this.orbitingCubes.forEach(cube => {
                            cube.userData.angle += deltaTime * 2.2;
                            cube.position.x = Math.cos(cube.userData.angle) * cube.userData.radius;
                            cube.position.z = Math.sin(cube.userData.angle) * cube.userData.radius;
                            // Spiral up and down
                            const spiral = Math.sin(cube.userData.angle * 2 + cube.userData.spiralPhase) * 0.2;
                            cube.position.y = 0.4 + spiral;
                            cube.rotation.x += deltaTime * 3;
                            cube.rotation.y += deltaTime * 3;
                        });
                    }
                    if (this.towerCore) {
                        this.towerCore.rotation.x += deltaTime * 1.5;
                        this.towerCore.rotation.y += deltaTime * 2;
                        const pulse = Math.sin(this.time * 3) * 0.08 + 1;
                        this.towerCore.scale.set(pulse, pulse, pulse);
                    }
                }

                // Find and shoot target
                const target = this.findTarget(enemies);
                if (target) {
                    // Rotate pedestal to face target
                    if (this.pedestal) {
                        const lookTarget = target.mesh.position.clone();
                        lookTarget.y = this.pedestal.position.y;
                        this.pedestal.lookAt(lookTarget);
                    }

                    return this.shoot(target, currentTime, enemies, gameSpeed);
                }
                return null;
            }

            destroy() {
                this.scene.remove(this.group);
                this.group.traverse((child) => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) child.material.dispose();
                });
            }
        }

        // ============================================
        // GLOWING PROJECTILE CLASS
        // ============================================
        class Projectile {
            constructor(scene, from, to, specialization) {
                this.scene = scene;
                this.lifetime = 500;
                this.createdAt = Date.now();
                this.specialization = specialization;

                if (specialization === 'splash') {
                    // Splash creates a burst sphere
                    const sphereGeo = new THREE.SphereGeometry(0.25, 12, 12);
                    const sphereMat = new THREE.MeshBasicMaterial({
                        color: 0xff0000,
                        transparent: true,
                        opacity: 0.9
                    });
                    this.mesh = new THREE.Mesh(sphereGeo, sphereMat);
                    this.mesh.position.copy(to);

                    // Add outer glow sphere
                    const glowSphereGeo = new THREE.SphereGeometry(0.35, 12, 12);
                    const glowSphereMat = new THREE.MeshBasicMaterial({
                        color: 0xff6666,
                        transparent: true,
                        opacity: 0.4
                    });
                    this.glowMesh = new THREE.Mesh(glowSphereGeo, glowSphereMat);
                    this.glowMesh.position.copy(to);

                    this.scene.add(this.mesh);
                    this.scene.add(this.glowMesh);
                } else {
                    // Create cylinder beam between from and to
                    const direction = new THREE.Vector3().subVectors(to, from);
                    const distance = direction.length();

                    // Core beam
                    const beamGeo = new THREE.CylinderGeometry(0.04, 0.04, distance, 8);
                    const beamMat = new THREE.MeshBasicMaterial({
                        color: 0x000000,
                        transparent: true,
                        opacity: 1
                    });
                    this.beam = new THREE.Mesh(beamGeo, beamMat);

                    // Position and orient the beam
                    this.beam.position.copy(from).add(direction.multiplyScalar(0.5));
                    this.beam.quaternion.setFromUnitVectors(
                        new THREE.Vector3(0, 1, 0),
                        direction.normalize()
                    );

                    // Glow beam
                    const glowGeo = new THREE.CylinderGeometry(0.08, 0.08, distance, 8);
                    const glowMat = new THREE.MeshBasicMaterial({
                        color: 0xff0000,
                        transparent: true,
                        opacity: 0.6
                    });
                    this.glowBeam = new THREE.Mesh(glowGeo, glowMat);
                    this.glowBeam.position.copy(this.beam.position);
                    this.glowBeam.quaternion.copy(this.beam.quaternion);

                    this.scene.add(this.beam);
                    this.scene.add(this.glowBeam);
                }
            }

            update() {
                const age = Date.now() - this.createdAt;
                if (age > this.lifetime) {
                    this.destroy();
                    return false;
                }

                // Fade out quickly
                const fadeAmount = 1 - (age / this.lifetime);

                if (this.specialization === 'splash') {
                    // Expand and fade the splash sphere
                    const scale = 1 + (age / this.lifetime) * 3;
                    this.mesh.scale.set(scale, scale, scale);
                    this.mesh.material.opacity = fadeAmount * 0.9;
                    this.glowMesh.scale.set(scale, scale, scale);
                    this.glowMesh.material.opacity = fadeAmount * 0.4;
                } else {
                    this.beam.material.opacity = fadeAmount;
                    this.glowBeam.material.opacity = fadeAmount * 0.6;
                }

                return true;
            }

            destroy() {
                if (this.specialization === 'splash') {
                    this.scene.remove(this.mesh);
                    this.scene.remove(this.glowMesh);
                    this.mesh.geometry.dispose();
                    this.mesh.material.dispose();
                    this.glowMesh.geometry.dispose();
                    this.glowMesh.material.dispose();
                } else {
                    this.scene.remove(this.beam);
                    this.scene.remove(this.glowBeam);
                    this.beam.geometry.dispose();
                    this.beam.material.dispose();
                    this.glowBeam.geometry.dispose();
                    this.glowBeam.material.dispose();
                }
            }
        }

        // ============================================
        // GAME MANAGER
        // ============================================
        class GameManager {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.composer = null;
                this.raycaster = new THREE.Raycaster();
                this.mouse = new THREE.Vector2();
                this.clock = new THREE.Clock();

                this.grid = [];
                this.towers = [];
                this.enemies = [];
                this.projectiles = [];

                this.gold = CONFIG.INITIAL_GOLD;
                this.lives = CONFIG.INITIAL_LIVES;
                this.wave = 0;
                this.waveInProgress = false;
                this.selectedTower = null;
                this.pendingPlacement = null;

                // Game speed and pause
                this.gameSpeed = 1.0;
                this.isPaused = false;

                // Camera rotation
                this.cameraRotation = Math.PI / 4; // 45 degrees initial
                this.cameraDistance = Math.sqrt(10 * 10 + 10 * 10 + 10 * 10);

                // Hover highlight
                this.hoveredObject = null;
                this.hoverIndicator = null;

                this.init();
                this.setupEventListeners();
                this.animate();
            }

            init() {
                // Scene
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x000000);
                this.scene.fog = new THREE.FogExp2(0x000011, 0.05);

                // Orthographic Camera - Isometric 45-degree angle
                const aspect = window.innerWidth / window.innerHeight;
                const frustumSize = 12;
                this.camera = new THREE.OrthographicCamera(
                    frustumSize * aspect / -2,
                    frustumSize * aspect / 2,
                    frustumSize / 2,
                    frustumSize / -2,
                    0.1,
                    1000
                );
                this.camera.position.set(10, 10, 10);
                this.camera.lookAt(0, 0, 0);

                // Renderer
                const canvas = document.getElementById('gameCanvas');
                this.renderer = new THREE.WebGLRenderer({
                    canvas,
                    antialias: true
                });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(window.devicePixelRatio);

                // Post-processing with UnrealBloomPass
                this.composer = new EffectComposer(this.renderer);
                const renderPass = new RenderPass(this.scene, this.camera);
                this.composer.addPass(renderPass);

                const bloomPass = new UnrealBloomPass(
                    new THREE.Vector2(window.innerWidth, window.innerHeight),
                    0.8,  // Strength (reduced from 1.5)
                    0.3,  // Radius (reduced from 0.4)
                    0.9  // Threshold (increased from 0.85)
                );
                this.composer.addPass(bloomPass);

                // Add scanlines effect
                this.scanlinesPass = new ShaderPass(ScanlinesShader);
                this.composer.addPass(this.scanlinesPass);

                // Lights
                const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
                this.scene.add(ambientLight);

                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(5, 10, 5);
                this.scene.add(directionalLight);

                // Add point lights for neon atmosphere
                const pointLight1 = new THREE.PointLight(0x00ffff, 2, 20);
                pointLight1.position.set(-3, 3, -3);
                this.scene.add(pointLight1);

                const pointLight2 = new THREE.PointLight(0xff3333, 2, 20);
                pointLight2.position.set(3, 3, 3);
                this.scene.add(pointLight2);

                // Create starfield background
                this.createStarfield();

                // Create grid
                this.createGrid();

                // Update UI
                this.updateUI();
            }

            createStarfield() {
                const starCount = 200;
                const starGeometry = new THREE.BufferGeometry();
                const starPositions = new Float32Array(starCount * 3);
                const starSizes = new Float32Array(starCount);

                // Distribute stars in a large sphere around the scene
                const radius = 50;
                for (let i = 0; i < starCount; i++) {
                    const i3 = i * 3;

                    // Random spherical coordinates
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos((Math.random() * 2) - 1);
                    const r = radius + Math.random() * 10;

                    starPositions[i3] = r * Math.sin(phi) * Math.cos(theta);
                    starPositions[i3 + 1] = r * Math.sin(phi) * Math.sin(theta);
                    starPositions[i3 + 2] = r * Math.cos(phi);

                    // Vary star sizes
                    starSizes[i] = Math.random() * 2 + 0.5;
                }

                starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
                starGeometry.setAttribute('size', new THREE.BufferAttribute(starSizes, 1));

                const starMaterial = new THREE.PointsMaterial({
                    color: 0xffffff,
                    size: 0.15,
                    sizeAttenuation: true,
                    transparent: true,
                    opacity: 0.8,
                    map: this.createStarTexture(),
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });

                this.starfield = new THREE.Points(starGeometry, starMaterial);
                this.scene.add(this.starfield);
            }

            createStarTexture() {
                const canvas = document.createElement('canvas');
                canvas.width = 32;
                canvas.height = 32;
                const ctx = canvas.getContext('2d');

                const gradient = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
                gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
                gradient.addColorStop(0.2, 'rgba(255, 255, 255, 0.8)');
                gradient.addColorStop(0.4, 'rgba(255, 255, 255, 0.3)');
                gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');

                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, 32, 32);

                const texture = new THREE.CanvasTexture(canvas);
                return texture;
            }

            createGrid() {
                const pathSet = new Set(PATH.map(p => `${p.x},${p.z}`));
                const startPos = PATH[0];
                const endPos = PATH[PATH.length - 1];

                for (let x = 0; x < CONFIG.GRID_SIZE; x++) {
                    this.grid[x] = [];
                    for (let z = 0; z < CONFIG.GRID_SIZE; z++) {
                        const isPath = pathSet.has(`${x},${z}`);
                        const isStart = x === startPos.x && z === startPos.z;
                        const isEnd = x === endPos.x && z === endPos.z;
                        const worldX = x - CONFIG.GRID_SIZE/2 + 0.5;
                        const worldZ = z - CONFIG.GRID_SIZE/2 + 0.5;

                        if (isPath) {
                            // Path tiles with special colors for start/end
                            const geometry = new THREE.BoxGeometry(
                                CONFIG.TILE_SIZE * 0.95,
                                0.1,
                                CONFIG.TILE_SIZE * 0.95
                            );

                            let tileColor, emissiveColor, borderColor;
                            if (isStart) {
                                // Yellow start tile
                                tileColor = 0xffdd00;
                                emissiveColor = 0xffff00;
                                borderColor = 0xffff00;
                            } else if (isEnd) {
                                // Red end tile
                                tileColor = 0xff0000;
                                emissiveColor = 0xff0000;
                                borderColor = 0xff0000;
                            } else {
                                // Orange regular path
                                tileColor = 0xff8800;
                                emissiveColor = 0xff8800;
                                borderColor = 0xff8800;
                            }

                            const material = new THREE.MeshStandardMaterial({
                                color: tileColor,
                                emissive: emissiveColor,
                                emissiveIntensity: 1.8,
                                metalness: 0.9,
                                roughness: 0.1,
                                transparent: true,
                                opacity: 0.7
                            });
                            const tile = new THREE.Mesh(geometry, material);
                            tile.position.set(worldX, 0, worldZ);
                            this.scene.add(tile);

                            // Glowing border for path
                            const borderGeo = new THREE.EdgesGeometry(geometry);
                            const borderMat = new THREE.LineBasicMaterial({
                                color: borderColor,
                                linewidth: 2
                            });
                            const border = new THREE.LineSegments(borderGeo, borderMat);
                            tile.add(border);

                            this.grid[x][z] = { type: 'path', mesh: tile, pathIndex: PATH.findIndex(p => p.x === x && p.z === z) };
                        } else {
                            // Elevated buildable platform (brighter)
                            const geometry = new THREE.BoxGeometry(
                                CONFIG.TILE_SIZE,
                                CONFIG.ELEVATION_HEIGHT,
                                CONFIG.TILE_SIZE
                            );
                            const material = new THREE.MeshStandardMaterial({
                                color: 0x2a2a4e,
                                emissive: 0x1f1f3e,
                                emissiveIntensity: 0.6,
                                metalness: 0.6,
                                roughness: 0.4,
                                // Ready for texture: map: pattern
                            });
                            const tile = new THREE.Mesh(geometry, material);
                            tile.position.set(worldX, CONFIG.ELEVATION_HEIGHT/2, worldZ);
                            tile.userData = { gridX: x, gridZ: z, buildable: true };
                            this.scene.add(tile);

                            // Glowing circuit border (brighter)
                            const borderGeo = new THREE.EdgesGeometry(geometry);
                            const borderMat = new THREE.LineBasicMaterial({
                                color: 0x00ffff,
                                linewidth: 2
                            });
                            const border = new THREE.LineSegments(borderGeo, borderMat);
                            border.material.transparent = true;
                            border.material.opacity = 0.8;
                            tile.add(border);

                            this.grid[x][z] = { type: 'elevated', mesh: tile, tower: null };
                        }
                    }
                }
            }

            setupEventListeners() {
                window.addEventListener('resize', () => this.onWindowResize());
                window.addEventListener('click', (e) => this.onClick(e));
                window.addEventListener('mousemove', (e) => this.onMouseMove(e));
                window.addEventListener('keydown', (e) => this.onKeyDown(e));

                document.getElementById('waveBtn').addEventListener('click', () => {
                    this.startWave();
                });

                document.getElementById('upgradeBtn').addEventListener('click', () => {
                    this.upgradeTower();
                });

                document.getElementById('closeBtn').addEventListener('click', () => {
                    this.closeUpgradePanel();
                });

                // Upgrade tree specialization options
                const upgradeOptions = document.querySelectorAll('.upgrade-option');
                upgradeOptions.forEach(option => {
                    option.addEventListener('click', (e) => {
                        e.stopPropagation();
                        if (!this.selectedTower || this.selectedTower.specialization) return;

                        // Remove previous selection
                        upgradeOptions.forEach(opt => opt.classList.remove('selected'));
                        option.classList.add('selected');

                        const type = option.getAttribute('data-type');
                        this.specializeTower(type);
                    });
                });

                // Prevent clicks on panels
                document.getElementById('upgradePanel').addEventListener('click', (e) => {
                    e.stopPropagation();
                });

                document.getElementById('confirmPanel').addEventListener('click', (e) => {
                    e.stopPropagation();
                });

                document.getElementById('confirmBuildBtn').addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.confirmTowerPlacement();
                });

                document.getElementById('cancelBuildBtn').addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.cancelTowerPlacement();
                });

                // Pause button
                document.getElementById('pauseBtn').addEventListener('click', () => {
                    this.togglePause();
                });

                // Speed control buttons
                const speedButtons = document.querySelectorAll('.speedBtn');
                speedButtons.forEach(btn => {
                    btn.addEventListener('click', () => {
                        const speed = parseFloat(btn.getAttribute('data-speed'));
                        this.setGameSpeed(speed);

                        // Update active state
                        speedButtons.forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                    });
                });

                // Rotation buttons
                document.getElementById('rotateLeftBtn').addEventListener('click', () => {
                    this.rotateCamera(-Math.PI / 4);
                });

                document.getElementById('rotateRightBtn').addEventListener('click', () => {
                    this.rotateCamera(Math.PI / 4);
                });
            }

            togglePause() {
                this.isPaused = !this.isPaused;
                const pauseBtn = document.getElementById('pauseBtn');
                if (this.isPaused) {
                    pauseBtn.textContent = '‚ñ∂Ô∏è RESUME';
                } else {
                    pauseBtn.textContent = '‚è∏Ô∏è PAUSE';
                }
            }

            setGameSpeed(speed) {
                this.gameSpeed = speed;
            }

            rotateCamera(angleChange) {
                this.cameraRotation += angleChange;
                this.updateCameraPosition();
            }

            updateCameraPosition() {
                const height = 10;
                const radius = Math.sqrt(this.cameraDistance * this.cameraDistance - height * height);

                this.camera.position.x = radius * Math.cos(this.cameraRotation);
                this.camera.position.y = height;
                this.camera.position.z = radius * Math.sin(this.cameraRotation);
                this.camera.lookAt(0, 0, 0);
            }

            onKeyDown(event) {
                if (event.key === 'q' || event.key === 'Q') {
                    this.rotateCamera(-Math.PI / 4);
                } else if (event.key === 'e' || event.key === 'E') {
                    this.rotateCamera(Math.PI / 4);
                }
            }

            onMouseMove(event) {
                this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

                this.raycaster.setFromCamera(this.mouse, this.camera);

                // Clear previous hover
                if (this.hoveredObject) {
                    if (this.hoveredObject.userData.isHoverIndicator) {
                        // Remove hover indicator
                        this.scene.remove(this.hoveredObject);
                        this.hoveredObject.geometry.dispose();
                        this.hoveredObject.material.dispose();
                        // Dispose border too
                        if (this.hoveredObject.children.length > 0) {
                            this.hoveredObject.children.forEach(child => {
                                if (child.geometry) child.geometry.dispose();
                                if (child.material) child.material.dispose();
                            });
                        }
                    }
                    this.hoveredObject = null;
                }

                // Check for tile/tower hover - only check tile meshes, not children
                const allTiles = [];
                for (let x = 0; x < CONFIG.GRID_SIZE; x++) {
                    for (let z = 0; z < CONFIG.GRID_SIZE; z++) {
                        const cell = this.grid[x][z];
                        if (cell.type === 'elevated') {
                            allTiles.push(cell.mesh);
                        }
                    }
                }

                // Only intersect the tiles themselves, not their children (false parameter)
                const tileIntersects = this.raycaster.intersectObjects(allTiles, false);

                if (tileIntersects.length > 0) {
                    const tile = tileIntersects[0].object;

                    if (tile && tile.userData.buildable) {
                        const gridX = tile.userData.gridX;
                        const gridZ = tile.userData.gridZ;
                        const cell = this.grid[gridX][gridZ];

                        // Create hover indicator
                        const worldX = gridX - CONFIG.GRID_SIZE/2 + 0.5;
                        const worldZ = gridZ - CONFIG.GRID_SIZE/2 + 0.5;

                        let hoverColor = 0x00ffff;
                        let hoverHeight = CONFIG.ELEVATION_HEIGHT + 0.1;

                        if (cell.tower) {
                            // Hovering over tower - highlight in yellow
                            hoverColor = 0xffff00;
                            hoverHeight = CONFIG.ELEVATION_HEIGHT + 1.2;
                        }

                        const geometry = new THREE.BoxGeometry(1.05, hoverHeight, 1.05);
                        const material = new THREE.MeshBasicMaterial({
                            color: hoverColor,
                            transparent: true,
                            opacity: 0.25,
                            wireframe: false,
                            depthTest: false
                        });
                        const hoverBox = new THREE.Mesh(geometry, material);
                        hoverBox.position.set(worldX, hoverHeight / 2, worldZ);
                        hoverBox.userData.isHoverIndicator = true;
                        hoverBox.renderOrder = 999;

                        // Add wireframe border
                        const borderGeo = new THREE.EdgesGeometry(geometry);
                        const borderMat = new THREE.LineBasicMaterial({
                            color: hoverColor,
                            linewidth: 3,
                            depthTest: false
                        });
                        const border = new THREE.LineSegments(borderGeo, borderMat);
                        border.renderOrder = 1000;
                        hoverBox.add(border);

                        this.scene.add(hoverBox);
                        this.hoveredObject = hoverBox;
                    }
                }
            }

            onWindowResize() {
                const aspect = window.innerWidth / window.innerHeight;
                const frustumSize = 12;
                this.camera.left = frustumSize * aspect / -2;
                this.camera.right = frustumSize * aspect / 2;
                this.camera.top = frustumSize / 2;
                this.camera.bottom = frustumSize / -2;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.composer.setSize(window.innerWidth, window.innerHeight);
            }

            onClick(event) {
                // Initialize sound on first click
                if (!soundSystem.initialized) {
                    soundSystem.init();
                }

                this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

                this.raycaster.setFromCamera(this.mouse, this.camera);

                // First, check ALL tiles (not just buildable) to determine which grid cell was clicked
                const allTiles = [];
                for (let x = 0; x < CONFIG.GRID_SIZE; x++) {
                    for (let z = 0; z < CONFIG.GRID_SIZE; z++) {
                        const cell = this.grid[x][z];
                        if (cell.type === 'elevated') {
                            allTiles.push(cell.mesh);
                        }
                    }
                }

                const tileIntersects = this.raycaster.intersectObjects(allTiles, false);

                if (tileIntersects.length > 0) {
                    // Get the tile mesh directly
                    const tile = tileIntersects[0].object;

                    if (tile && tile.userData.buildable) {
                        const gridX = tile.userData.gridX;
                        const gridZ = tile.userData.gridZ;
                        const cell = this.grid[gridX][gridZ];

                        // Check if this tile has a tower
                        if (cell.tower) {
                            this.selectTower(cell.tower);
                            return;
                        }

                        // Otherwise, show placement confirmation if we have enough gold
                        if (this.gold >= CONFIG.TOWER_COST) {
                            this.showPlacementConfirmation(gridX, gridZ);
                            return;
                        }
                    }
                }

                // Close panels if clicking elsewhere
                this.closeUpgradePanel();
                this.cancelTowerPlacement();
            }

            showPlacementConfirmation(gridX, gridZ) {
                // Close upgrade panel if open
                this.closeUpgradePanel();

                // Store pending placement
                this.pendingPlacement = { gridX, gridZ };

                // Show confirmation panel
                document.getElementById('confirmPanel').style.display = 'block';
            }

            confirmTowerPlacement() {
                if (!this.pendingPlacement) return;

                const { gridX, gridZ } = this.pendingPlacement;
                this.placeTower(gridX, gridZ);

                // Close panel
                document.getElementById('confirmPanel').style.display = 'none';
                this.pendingPlacement = null;
            }

            cancelTowerPlacement() {
                document.getElementById('confirmPanel').style.display = 'none';
                this.pendingPlacement = null;
            }

            placeTower(gridX, gridZ) {
                if (this.gold < CONFIG.TOWER_COST) return;

                const cell = this.grid[gridX][gridZ];
                if (cell.type === 'elevated' && !cell.tower) {
                    this.gold -= CONFIG.TOWER_COST;
                    const tower = new Tower(this.scene, gridX, gridZ);
                    this.towers.push(tower);
                    cell.tower = tower;
                    this.updateUI();
                    soundSystem.playTowerPlace();
                }
            }

            selectTower(tower) {
                // Hide range of previously selected tower
                if (this.selectedTower) {
                    this.selectedTower.showRange(false);
                }

                this.selectedTower = tower;
                tower.showRange(true);

                // Show upgrade panel
                document.getElementById('upgradePanel').style.display = 'block';
                document.getElementById('towerLevel').textContent = tower.level;
                document.getElementById('towerRange').textContent = tower.range.toFixed(1);
                document.getElementById('towerFireRate').textContent = tower.fireRate.toFixed(1) + '/s';
                document.getElementById('towerDamage').textContent = tower.damage.toFixed(1);

                // Show specialization name
                const specializationNames = {
                    rapidfire: 'üî• Rapid Fire Tower',
                    sniper: 'üéØ Sniper Tower',
                    frost: '‚ùÑÔ∏è Frost Tower',
                    splash: 'üí• Splash Tower',
                    poison: '‚ò†Ô∏è Poison Tower'
                };
                document.getElementById('towerSpecialization').textContent =
                    tower.specialization ? specializationNames[tower.specialization] : 'Basic Tower';

                // Show/hide appropriate upgrade sections
                if (tower.level === 1 && !tower.specialization) {
                    // Show specialization tree for level 1 towers
                    document.getElementById('upgradeTreeSection').style.display = 'block';
                    document.getElementById('upgradeStandardSection').style.display = 'none';
                } else {
                    // Show standard upgrade button
                    document.getElementById('upgradeTreeSection').style.display = 'none';
                    document.getElementById('upgradeStandardSection').style.display = 'block';

                    const upgradeBtn = document.getElementById('upgradeBtn');

                    // Check if at max level
                    if (tower.maxLevel && tower.level >= tower.maxLevel) {
                        upgradeBtn.textContent = 'MAX LEVEL';
                        upgradeBtn.disabled = true;
                    } else {
                        upgradeBtn.textContent = `‚¨ÜÔ∏è UPGRADE (${tower.upgradeCost}g)`;
                        upgradeBtn.disabled = this.gold < tower.upgradeCost;
                    }
                }
            }

            specializeTower(type) {
                if (!this.selectedTower) return;
                if (this.gold < 100) return;

                this.gold -= 100;
                this.selectedTower.specialize(type);
                this.updateUI();

                // Close and reopen panel to update UI
                this.closeUpgradePanel();
            }

            upgradeTower() {
                if (!this.selectedTower) return;
                if (this.gold < this.selectedTower.upgradeCost) return;

                this.gold -= this.selectedTower.upgradeCost;
                const upgraded = this.selectedTower.upgrade();

                if (upgraded) {
                    soundSystem.playUpgrade();
                    this.updateUI();
                    // Update panel
                    this.selectTower(this.selectedTower);
                }
            }

            closeUpgradePanel() {
                document.getElementById('upgradePanel').style.display = 'none';
                if (this.selectedTower) {
                    this.selectedTower.showRange(false);
                    this.selectedTower = null;
                }
            }

            startWave() {
                if (this.waveInProgress) return;

                this.wave++;
                this.waveInProgress = true;
                this.updateUI();

                // Balanced difficulty with faster spawn rates
                let enemyCount, spawnInterval;
                if (this.wave === 1) {
                    enemyCount = 7;
                    spawnInterval = 900;
                } else if (this.wave === 2) {
                    enemyCount = 9;
                    spawnInterval = 750;
                } else {
                    enemyCount = 10 + this.wave * 4;
                    spawnInterval = Math.max(500, 750 - this.wave * 20);
                }

                for (let i = 0; i < enemyCount; i++) {
                    setTimeout(() => {
                        const enemy = new Enemy(this.scene, PATH, this.wave);
                        this.enemies.push(enemy);
                    }, i * spawnInterval);
                }

                // Check wave completion
                setTimeout(() => {
                    const checkComplete = setInterval(() => {
                        const aliveEnemies = this.enemies.filter(e => e.alive);
                        if (aliveEnemies.length === 0 && this.waveInProgress) {
                            this.waveInProgress = false;
                            soundSystem.playWaveComplete();
                            clearInterval(checkComplete);
                        }
                    }, 500);
                }, enemyCount * spawnInterval + 5000);
            }

            updateUI() {
                document.getElementById('gold').textContent = this.gold;
                document.getElementById('lives').textContent = this.lives;
                document.getElementById('wave').textContent = this.wave;
            }

            update() {
                // Update scanlines even when paused
                if (this.scanlinesPass) {
                    this.scanlinesPass.uniforms.time.value = Date.now() * 0.001;
                }

                // Slowly rotate starfield
                if (this.starfield) {
                    this.starfield.rotation.y += 0.0001;
                    this.starfield.rotation.x += 0.00005;
                }

                // Skip game update if paused
                if (this.isPaused) {
                    return;
                }

                const deltaTime = this.clock.getDelta();
                const currentTime = Date.now();

                // Apply game speed to deltaTime
                const adjustedDeltaTime = deltaTime * this.gameSpeed;

                // Update enemies
                for (let i = this.enemies.length - 1; i >= 0; i--) {
                    const enemy = this.enemies[i];
                    const result = enemy.update(this.gameSpeed);

                    if (result === 'escaped') {
                        this.lives--;
                        this.updateUI();
                        enemy.destroy();
                        this.enemies.splice(i, 1);

                        if (this.lives <= 0) {
                            soundSystem.playGameOver();
                            alert('üíÄ GAME OVER üíÄ\nFinal Wave: ' + this.wave);
                            location.reload();
                        }
                    } else if (!enemy.alive) {
                        this.gold += enemy.reward;
                        this.updateUI();

                        // Keep enemy for fade animation
                        setTimeout(() => {
                            enemy.destroy();
                            const index = this.enemies.indexOf(enemy);
                            if (index > -1) this.enemies.splice(index, 1);
                        }, 500);
                    }
                }

                // Update towers
                for (const tower of this.towers) {
                    const shot = tower.update(this.enemies, currentTime, adjustedDeltaTime, this.gameSpeed);
                    if (shot) {
                        const projectile = new Projectile(this.scene, shot.from, shot.to, shot.specialization);
                        this.projectiles.push(projectile);
                    }
                }

                // Update projectiles
                for (let i = this.projectiles.length - 1; i >= 0; i--) {
                    if (!this.projectiles[i].update()) {
                        this.projectiles.splice(i, 1);
                    }
                }
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                this.update();
                this.composer.render();
            }
        }

        // ============================================
        // START GAME
        // ============================================
        const game = new GameManager();

        console.log('‚ö° GEOMETRIC GALAXY TD LOADED ‚ö°');
        console.log('üé® Ready for Spoonflower patterns');
        console.log('üì¶ Tower pedestal UV mapped for textures');
        console.log('‚ú® UnrealBloomPass active for neon glow');
        console.log('üî• Full upgrade tree with 5 specializations');
    </script>
</body>
</html>
