<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Geometric Galaxy TD - Celestial Showcase</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300;700&display=swap');
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Space Grotesk', sans-serif; overflow: hidden; background: #000; color: #fff; }
        #gameCanvas { display: block; width: 100%; height: 100vh; }

        #ui {
            position: absolute; top: 30px; left: 30px; 
            padding: 20px; border-left: 2px solid #00ffff;
            z-index: 100; pointer-events: none;
            background: rgba(0, 0, 0, 0.6); backdrop-filter: blur(10px);
        }

        #controls {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 15px; align-items: center; z-index: 1000;
            background: rgba(255, 255, 255, 0.05); padding: 12px 30px;
            border-radius: 100px; border: 1px solid rgba(0,255,255,0.3);
            backdrop-filter: blur(15px);
        }

        button {
            background: transparent; color: #00ffff; border: 1px solid rgba(0,255,255,0.4);
            padding: 8px 18px; font-family: 'Space Grotesk', sans-serif; font-size: 11px;
            cursor: pointer; transition: all 0.3s; text-transform: uppercase; letter-spacing: 2px;
            border-radius: 50px;
        }

        button:hover:not(:disabled) { background: #00ffff; color: #000; box-shadow: 0 0 20px #00ffff; }
        button.active { background: #00ffff; color: #000; border-color: #00ffff; }
        
        .modal {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95); padding: 40px; border-radius: 20px;
            border: 2px solid #ff3366; display: none; z-index: 2000; 
            min-width: 350px; text-align: center; backdrop-filter: blur(20px);
        }

        .upgrade-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 20px; }
        h2 { font-weight: 700; font-size: 20px; letter-spacing: 4px; margin-bottom: 5px; color: #00ffff; }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <div id="ui">
        <h2>NEURAL GRID</h2>
        <p>ENERGY: <span id="gold" style="color:#00ffff">500</span></p>
        <p>THREAT: <span id="wave" style="color:#ff3366">0</span></p>
    </div>

    <div id="buildModal" class="modal">
        <h3 style="color:#ff3366; margin-bottom:10px;">DEPLOY MONOLITH</h3>
        <p style="margin:20px 0; font-size:12px; opacity:0.7;">ALLOCATE 100 ENERGY UNITS?</p>
        <div style="display:flex; gap:10px;">
            <button id="confirmBuild" style="flex:1; border-color:#00ffff; color:#00ffff;">DEPLOY</button>
            <button id="cancelBuild" style="flex:1;">ABORT</button>
        </div>
    </div>

    <div id="upgradeModal" class="modal">
        <h3 style="color:#00ffff; margin-bottom:15px;">EVOLUTION TREE</h3>
        <div class="upgrade-grid">
            <button onclick="game.specialize('rapidfire')">STORM</button>
            <button onclick="game.specialize('sniper')">RAILGUN</button>
            <button onclick="game.specialize('splash')">NOVA</button>
            <button onclick="game.specialize('frost')">ZERO</button>
        </div>
        <button onclick="document.getElementById('upgradeModal').style.display='none'" style="width:100%; margin-top:20px;">CLOSE</button>
    </div>

    <div id="controls">
        <button id="pauseBtn">⏸</button>
        <button class="speed-btn active" data-speed="1">1X</button>
        <button class="speed-btn" data-speed="2.5">FAST</button>
        <button id="waveBtn" style="background:#ff3366; border:none; color:#fff;">START WAVE</button>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        const PATH = [{x:0,z:1},{x:1,z:1},{x:2,z:1},{x:3,z:1},{x:3,z:2},{x:3,z:3},{x:3,z:4},{x:2,z:4},{x:1,z:4},{x:1,z:5},{x:1,z:6},{x:1,z:7},{x:2,z:7},{x:3,z:7},{x:4,z:7},{x:5,z:7},{x:5,z:6},{x:5,z:5},{x:6,z:5},{x:7,z:5},{x:8,z:5},{x:8,z:6},{x:8,z:7},{x:8,z:8},{x:9,z:8}];

        // --- ENEMY ---
        class Enemy {
            constructor(scene, wave) {
                this.scene = scene; this.pathIndex = 0; this.alive = true;
                this.health = 3 + wave * 2.5; this.speed = 0.015 + (wave * 0.001);
                this.mesh = new THREE.Mesh(
                    new THREE.IcosahedronGeometry(0.25, 0), 
                    new THREE.MeshStandardMaterial({ color: 0x00ffff, emissive: 0x00ffff, emissiveIntensity: 0.5, wireframe: true })
                );
                this.mesh.position.set(PATH[0].x - 5 + 0.5, 0.4, PATH[0].z - 5 + 0.5);
                scene.add(this.mesh);
            }
            update(gameSpeed) {
                if (!this.alive) return;
                const target = PATH[this.pathIndex];
                const targetPos = new THREE.Vector3(target.x - 5 + 0.5, 0.4, target.z - 5 + 0.5);
                const dir = targetPos.clone().sub(this.mesh.position);
                if (dir.length() < 0.1) {
                    this.pathIndex++;
                    if (this.pathIndex >= PATH.length) { this.alive = false; return 'escaped'; }
                } else { this.mesh.position.add(dir.normalize().multiplyScalar(this.speed * gameSpeed)); }
                this.mesh.rotation.y += 0.05 * gameSpeed;
                return true;
            }
        }

        // --- TOWER ---
        class Tower {
            constructor(scene, x, z) {
                this.scene = scene; this.gridX = x; this.gridZ = z;
                this.range = 3.5; this.damage = 1; this.fireRate = 1.5;
                this.special = 'none'; this.lastFire = 0;
                this.group = new THREE.Group();
                this.group.position.set(x - 5 + 0.5, 0.4, z - 5 + 0.5);
                this.originalPos = this.group.position.clone();
                this.createModel();
                scene.add(this.group);
            }
            createModel() {
                while(this.group.children.length > 0) this.group.remove(this.group.children[0]);
                const p = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.1, 0.8), new THREE.MeshStandardMaterial({ color: 0x110000 }));
                this.group.add(p);
                
                let geo;
                if (this.special === 'none') geo = new THREE.BoxGeometry(0.3, 0.3, 0.3);
                else if (this.special === 'rapidfire') geo = new THREE.OctahedronGeometry(0.4);
                else if (this.special === 'sniper') geo = new THREE.BoxGeometry(0.3, 0.8, 0.3);
                else if (this.special === 'splash') geo = new THREE.SphereGeometry(0.35);
                else geo = new THREE.TorusGeometry(0.2, 0.08);
                
                this.body = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({ color: 0xff3366, emissive: 0xff3366, emissiveIntensity: 2, wireframe: true }));
                this.body.position.y = 0.5;
                this.group.add(this.body);
            }
            updatePulse(time) {
                this.body.material.emissiveIntensity = 2 + Math.sin(time * 5) * 1.5;
            }
            update(enemies, time, gameSpeed, onHit) {
                const target = enemies.find(e => e.alive && e.mesh.position.distanceTo(this.group.position) < this.range);
                if (target) {
                    if(this.special === 'sniper') { this.body.lookAt(target.mesh.position); this.body.scale.z = 1.5; }
                    if (time - this.lastFire > (1000/this.fireRate)/gameSpeed) {
                        this.lastFire = time;
                        this.lunge(target.mesh.position);
                        onHit(target, this.damage);
                        return true;
                    }
                } else if(this.special === 'sniper') this.body.scale.z = 1;
                return false;
            }
            lunge(targetPos) {
                const dir = targetPos.clone().sub(this.group.position).normalize().multiplyScalar(0.2);
                this.group.position.add(dir);
                setTimeout(() => this.group.position.copy(this.originalPos), 50);
            }
        }

        // --- GAME MANAGER ---
        class GameManager {
            constructor() {
                this.scene = new THREE.Scene(); this.gameSpeed = 1.0; this.isPaused = false;
                this.gold = 500; this.wave = 0; this.towers = []; this.enemies = []; this.tiles = [];
                this.init(); this.animate();
            }
            init() {
                const aspect = window.innerWidth / window.innerHeight;
                this.camera = new THREE.OrthographicCamera(-8*aspect, 8*aspect, 8, -8, 0.1, 1000);
                this.camera.position.set(12, 12, 12); this.camera.lookAt(0, 0, 0);
                this.renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('gameCanvas'), antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                
                this.composer = new EffectComposer(this.renderer);
                this.composer.addPass(new RenderPass(this.scene, this.camera));
                this.composer.addPass(new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.8, 0.3, 0.7));
                
                this.scene.add(new THREE.AmbientLight(0x404040, 0.5));

                // --- STARS ---
                const starGeo = new THREE.BufferGeometry();
                const starPos = [];
                for(let i=0; i<3000; i++) {
                    const r = 20 + Math.random() * 30;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    starPos.push(r * Math.sin(phi) * Math.cos(theta), r * Math.sin(phi) * Math.sin(theta), r * Math.cos(phi));
                }
                starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPos, 3));
                this.stars = new THREE.Points(starGeo, new THREE.PointsMaterial({ color: 0xffffff, size: 0.06 }));
                this.scene.add(this.stars);

                // --- GHOST TOWER ---
                this.ghost = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.3, 0.3), new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true, transparent: true, opacity: 0.3 }));
                this.ghost.visible = false;
                this.scene.add(this.ghost);
                
                // --- GRID (BLUE GLASS) ---
                const pathSet = new Set(PATH.map(p => `${p.x},${p.z}`));
                for(let x=0; x<10; x++) {
                    for(let z=0; z<10; z++) {
                        const isP = pathSet.has(`${x},${z}`);
                        const tile = new THREE.Mesh(
                            new THREE.BoxGeometry(0.95, isP?0.05:0.1, 0.95), 
                            new THREE.MeshStandardMaterial({ 
                                color: isP ? 0x00ffff : 0x0088ff, 
                                transparent: true, 
                                opacity: isP ? 0.6 : 0.2,
                                emissive: isP ? 0x00ffff : 0x0088ff,
                                emissiveIntensity: isP ? 0.3 : 0.05
                            })
                        );
                        tile.position.set(x-5+0.5, 0, z-5+0.5);
                        tile.userData = { x, z, isP, tower: null };
                        this.scene.add(tile); this.tiles.push(tile);
                    }
                }
                this.raycaster = new THREE.Raycaster(); this.mouse = new THREE.Vector2();
                this.setupUI();
            }
            setupUI() {
                window.addEventListener('mousemove', e => { this.mouse.x = (e.clientX/window.innerWidth)*2-1; this.mouse.y = -(e.clientY/window.innerHeight)*2+1; });
                window.addEventListener('mousedown', (e) => {
                    if(e.target.tagName !== 'CANVAS') return;
                    this.raycaster.setFromCamera(this.mouse, this.camera);
                    const hit = this.raycaster.intersectObjects(this.tiles)[0];
                    if (hit) {
                        const obj = hit.object;
                        if (obj.userData.tower) { this.selectedTower = obj.userData.tower; document.getElementById('upgradeModal').style.display='block'; }
                        else if (!obj.userData.isP) { this.pendingTile = obj; document.getElementById('buildModal').style.display='block'; }
                    }
                });
                document.getElementById('confirmBuild').onclick = () => {
                    if (this.gold >= 100) {
                        this.gold -= 100; const t = new Tower(this.scene, this.pendingTile.userData.x, this.pendingTile.userData.z);
                        this.towers.push(t); this.pendingTile.userData.tower = t;
                        document.getElementById('buildModal').style.display = 'none'; this.updateUI();
                    }
                };
                document.getElementById('cancelBuild').onclick = () => document.getElementById('buildModal').style.display = 'none';
                document.getElementById('waveBtn').onclick = () => { this.wave++; this.updateUI(); for(let i=0; i<5+this.wave*3; i++) setTimeout(() => this.enemies.push(new Enemy(this.scene, this.wave)), i*700/this.gameSpeed); };
                document.querySelectorAll('.speed-btn').forEach(b => b.onclick = e => { this.gameSpeed = parseFloat(e.target.dataset.speed); document.querySelectorAll('.speed-btn').forEach(btn => btn.classList.remove('active')); e.target.classList.add('active'); });
                document.getElementById('pauseBtn').onclick = (e) => { this.isPaused = !this.isPaused; e.target.innerText = this.isPaused ? "▶" : "⏸"; };
            }
            specialize(type) {
                if(this.gold >= 150) {
                    this.gold -= 150; this.selectedTower.special = type;
                    if(type === 'sniper') { this.selectedTower.range = 8; this.selectedTower.damage = 10; this.selectedTower.fireRate = 0.5; }
                    if(type === 'rapidfire') { this.selectedTower.fireRate = 5; this.selectedTower.damage = 0.5; }
                    this.selectedTower.createModel(); document.getElementById('upgradeModal').style.display = 'none'; this.updateUI();
                }
            }
            updateUI() { document.getElementById('gold').innerText = this.gold; document.getElementById('wave').innerText = this.wave; }
            animate() {
                requestAnimationFrame(() => this.animate());
                if (!this.isPaused) {
                    const time = Date.now() * 0.001;
                    this.stars.rotation.y += 0.0001;

                    // Improved Interaction Logic
                    this.raycaster.setFromCamera(this.mouse, this.camera);
                    const hit = this.raycaster.intersectObjects(this.tiles)[0];
                    this.tiles.forEach(t => t.material.opacity = t.userData.isP ? 0.6 : 0.2);
                    this.ghost.visible = false;
                    
                    if (hit) {
                        hit.object.material.opacity = 0.8;
                        if(!hit.object.userData.isP && !hit.object.userData.tower) {
                            this.ghost.visible = true;
                            this.ghost.position.set(hit.object.position.x, 0.4, hit.object.position.z);
                        }
                    }

                    this.enemies.forEach((e, i) => {
                        const res = e.update(this.gameSpeed);
                        if (res === 'escaped' || e.health <= 0) {
                            if(res !== 'escaped') this.gold += 20;
                            this.scene.remove(e.mesh); this.enemies.splice(i, 1); this.updateUI();
                        }
                    });
                    this.towers.forEach(t => { t.updatePulse(time); t.update(this.enemies, Date.now(), this.gameSpeed, (target, dmg) => { target.health -= dmg; }); });
                }
                this.composer.render();
            }
        }
        const game = new GameManager(); window.game = game;
    </script>
</body>
</html>
