<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Geometric Galaxy TD - Starfield Edition</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Courier New', monospace; overflow: hidden; background: #000; }
        #gameCanvas { display: block; width: 100%; height: 100vh; }

        #ui {
            position: absolute; top: 20px; left: 20px; color: #00ffff;
            background: rgba(0, 0, 0, 0.85); padding: 20px;
            border-radius: 5px; border: 2px solid #00ffff; z-index: 100;
            text-shadow: 0 0 10px #00ffff; pointer-events: none;
        }

        #controls {
            position: absolute; bottom: 20px; left: 50%;
            transform: translateX(-50%); background: rgba(0, 0, 0, 0.85);
            padding: 15px 25px; border-radius: 5px; border: 2px solid #00ffff;
            display: flex; gap: 10px; align-items: center; z-index: 100;
        }

        button {
            background: rgba(0, 255, 255, 0.1); color: #00ffff;
            border: 2px solid #00ffff; padding: 8px 15px;
            font-family: 'Courier New', monospace; font-weight: bold;
            cursor: pointer; transition: all 0.2s;
        }

        button:hover { background: rgba(0, 255, 255, 0.3); box-shadow: 0 0 15px #00ffff; }
        button.active { background: #00ffff; color: #000; }
        button#pauseBtn.paused { border-color: #ff3333; color: #ff3333; }

        #upgradePanel {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95); padding: 30px; border-radius: 10px;
            border: 3px solid #00ffff; color: #00ffff; display: none; z-index: 200;
        }

        .stat { display: flex; justify-content: space-between; margin: 5px 0; }
        .upgrade-options { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 15px; }
        .upgrade-option { border: 1px solid #00ffff; padding: 10px; cursor: pointer; text-align: center; font-size: 12px; }
        .upgrade-option:hover { background: rgba(0, 255, 255, 0.2); }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <div id="ui">
        <h2>‚ö° GEOMETRIC GALAXY TD ‚ö°</h2>
        <p>üí∞ Gold: <span id="gold">500</span></p>
        <p>‚ù§Ô∏è Lives: <span id="lives">20</span></p>
        <p>üåä Wave: <span id="wave">0</span></p>
    </div>

    <div id="controls">
        <button id="pauseBtn">‚è∏ PAUSE</button>
        <div style="width: 2px; height: 30px; background: #00ffff; margin: 0 10px;"></div>
        <button class="speedBtn" data-speed="0.5">0.5x</button>
        <button class="speedBtn active" data-speed="1">1x</button>
        <button class="speedBtn" data-speed="1.5">1.5x</button>
        <button class="speedBtn" data-speed="3">3x</button>
        <div style="width: 2px; height: 30px; background: #00ffff; margin: 0 10px;"></div>
        <button id="waveBtn">‚ñ∂ START WAVE</button>
    </div>

    <div id="upgradePanel">
        <h3 id="towerSpecialization" style="color:#ff3333; margin-bottom:15px; text-align:center;">Basic Tower</h3>
        <div class="stat"><span>Level:</span><span id="towerLevel">1</span></div>
        <div class="stat"><span>Range:</span><span id="towerRange">3.0</span></div>
        <div class="stat"><span>Damage:</span><span id="towerDamage">1</span></div>
        
        <div id="upgradeTreeSection" style="display:none;">
            <div class="upgrade-options">
                <div class="upgrade-option" data-type="rapidfire">üî• RAPID</div>
                <div class="upgrade-option" data-type="sniper">üéØ SNIPER</div>
                <div class="upgrade-option" data-type="frost">‚ùÑÔ∏è FROST</div>
                <div class="upgrade-option" data-type="splash">üí• SPLASH</div>
            </div>
        </div>
        <button id="upgradeBtn" style="width:100%; margin-top:20px;">UPGRADE</button>
        <button id="closeBtn" style="width:100%; margin-top:10px; border-color:#ff3333; color:#ff3333;">CLOSE</button>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        const CONFIG = {
            GRID_SIZE: 10,
            TOWER_COST: 100,
            INITIAL_GOLD: 500,
            INITIAL_LIVES: 20,
            ELEVATION_HEIGHT: 0.5
        };

        const PATH = [
            {x: 0, z: 1}, {x: 1, z: 1}, {x: 2, z: 1}, {x: 3, z: 1},
            {x: 3, z: 2}, {x: 3, z: 3}, {x: 3, z: 4},
            {x: 2, z: 4}, {x: 1, z: 4}, {x: 1, z: 5},
            {x: 1, z: 6}, {x: 1, z: 7}, {x: 2, z: 7},
            {x: 3, z: 7}, {x: 4, z: 7}, {x: 5, z: 7},
            {x: 5, z: 6}, {x: 5, z: 5}, {x: 6, z: 5},
            {x: 7, z: 5}, {x: 8, z: 5}, {x: 8, z: 6},
            {x: 8, z: 7}, {x: 8, z: 8}, {x: 9, z: 8}
        ];

        // --- ENEMY CLASS ---
        class Enemy {
            constructor(scene, wave) {
                this.scene = scene;
                this.wave = wave;
                this.pathIndex = 0;
                this.health = 3 + wave * 1.5;
                this.speed = 0.015 + (wave * 0.002);
                this.alive = true;
                
                const geo = new THREE.IcosahedronGeometry(0.3, 0);
                const mat = new THREE.MeshStandardMaterial({ 
                    color: new THREE.Color().setHSL((wave * 0.15) % 1, 1, 0.5),
                    emissive: new THREE.Color().setHSL((wave * 0.15) % 1, 1, 0.3),
                    wireframe: true 
                });
                this.mesh = new THREE.Mesh(geo, mat);
                const start = PATH[0];
                this.mesh.position.set(start.x - 5 + 0.5, 0.4, start.z - 5 + 0.5);
                scene.add(this.mesh);
            }
            update(gameSpeed) {
                if (!this.alive) return;
                const target = PATH[this.pathIndex];
                const targetPos = new THREE.Vector3(target.x - 5 + 0.5, 0.4, target.z - 5 + 0.5);
                const dir = targetPos.clone().sub(this.mesh.position);
                if (dir.length() < 0.1) {
                    this.pathIndex++;
                    if (this.pathIndex >= PATH.length) return 'escaped';
                } else {
                    this.mesh.position.add(dir.normalize().multiplyScalar(this.speed * gameSpeed));
                }
                this.mesh.rotation.x += 0.02 * gameSpeed;
                return true;
            }
            takeDamage(amt) {
                this.health -= amt;
                if (this.health <= 0) { this.alive = false; this.scene.remove(this.mesh); return true; }
                return false;
            }
        }

        // --- TOWER CLASS ---
        class Tower {
            constructor(scene, x, z) {
                this.scene = scene;
                this.gridX = x; this.gridZ = z;
                this.level = 1; this.range = 3; this.fireRate = 1; this.damage = 1;
                this.lastFire = 0;
                this.group = new THREE.Group();
                
                // Pedestal
                const pGeo = new THREE.BoxGeometry(0.9, 0.2, 0.9);
                const pMat = new THREE.MeshStandardMaterial({ color: 0x1a1a2e, emissive: 0x00ffff, emissiveIntensity: 0.2 });
                this.pedestal = new THREE.Mesh(pGeo, pMat);
                this.group.add(this.pedestal);

                // Body
                const bGeo = new THREE.BoxGeometry(0.5, 0.6, 0.5);
                const bMat = new THREE.MeshStandardMaterial({ color: 0x00ffff, wireframe: true });
                this.body = new THREE.Mesh(bGeo, bMat);
                this.body.position.y = 0.4;
                this.group.add(this.body);

                this.group.position.set(x - 5 + 0.5, 0.6, z - 5 + 0.5);
                scene.add(this.group);
            }
            update(enemies, time, gameSpeed) {
                this.body.rotation.y += 0.01 * gameSpeed;
                const target = enemies.find(e => e.mesh.position.distanceTo(this.group.position) < this.range);
                if (target && time - this.lastFire > (1000 / this.fireRate) / gameSpeed) {
                    this.lastFire = time;
                    this.lunge(target.mesh.position);
                    return target;
                }
                return null;
            }
            lunge(targetPos) {
                const dir = targetPos.clone().sub(this.group.position).normalize().multiplyScalar(0.2);
                const orig = this.group.position.clone();
                this.group.position.add(dir);
                setTimeout(() => this.group.position.copy(orig), 50);
            }
        }

        // --- GAME MANAGER ---
        class GameManager {
            constructor() {
                this.scene = new THREE.Scene();
                this.isPaused = false;
                this.gameSpeed = 1.0;
                this.gold = 500;
                this.lives = 20;
                this.wave = 0;
                this.towers = [];
                this.enemies = [];
                this.grid = [];
                this.clock = new THREE.Clock();

                this.initGraphics();
                this.createStarfield();
                this.createGrid();
                this.setupUI();
                this.animate();
            }

            initGraphics() {
                const aspect = window.innerWidth / window.innerHeight;
                const d = 7;
                this.camera = new THREE.OrthographicCamera(-d*aspect, d*aspect, d, -d, 0.1, 1000);
                this.camera.position.set(10, 10, 10);
                this.camera.lookAt(0, 0, 0);

                this.renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('gameCanvas'), antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(window.devicePixelRatio);

                const renderScene = new RenderPass(this.scene, this.camera);
                const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
                this.composer = new EffectComposer(this.renderer);
                this.composer.addPass(renderScene);
                this.composer.addPass(bloomPass);

                this.scene.add(new THREE.AmbientLight(0x404040));
                const sun = new THREE.DirectionalLight(0xffffff, 1);
                sun.position.set(5, 10, 7);
                this.scene.add(sun);

                this.raycaster = new THREE.Raycaster();
                this.mouse = new THREE.Vector2();
                this.hoveredObj = null;
            }

            createStarfield() {
                const geo = new THREE.BufferGeometry();
                const pos = [];
                for(let i=0; i<1000; i++) {
                    pos.push((Math.random()-0.5)*50, (Math.random()-0.5)*50, (Math.random()-0.5)*50);
                }
                geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
                const mat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.05, transparent: true });
                this.stars = new THREE.Points(geo, mat);
                this.scene.add(this.stars);
            }

            createGrid() {
                const pathSet = new Set(PATH.map(p => `${p.x},${p.z}`));
                for(let x=0; x<10; x++) {
                    this.grid[x] = [];
                    for(let z=0; z<10; z++) {
                        const isPath = pathSet.has(`${x},${z}`);
                        const geo = new THREE.BoxGeometry(1, isPath ? 0.1 : 0.5, 1);
                        const mat = new THREE.MeshStandardMaterial({ 
                            color: isPath ? 0x002233 : 0x111111,
                            emissive: isPath ? 0x00ffff : 0x000000,
                            emissiveIntensity: 0.2
                        });
                        const tile = new THREE.Mesh(geo, mat);
                        tile.position.set(x-5+0.5, isPath ? 0 : 0.25, z-5+0.5);
                        tile.userData = { gridX: x, gridZ: z, isPath };
                        this.scene.add(tile);
                        
                        const edges = new THREE.EdgesGeometry(geo);
                        const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x00ffff }));
                        tile.add(line);
                        this.grid[x][z] = tile;
                    }
                }
            }

            setupUI() {
                window.addEventListener('mousemove', (e) => {
                    this.mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                    this.mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
                });

                window.addEventListener('click', () => {
                    if (this.hoveredObj && !this.hoveredObj.userData.isPath) {
                        const cell = this.hoveredObj.userData;
                        if (this.gold >= 100) {
                            this.gold -= 100;
                            const t = new Tower(this.scene, cell.gridX, cell.gridZ);
                            this.towers.push(t);
                            this.updateUI();
                        }
                    }
                });

                document.getElementById('waveBtn').onclick = () => {
                    this.wave++;
                    for(let i=0; i<5+this.wave; i++) {
                        setTimeout(() => this.enemies.push(new Enemy(this.scene, this.wave)), i*800/this.gameSpeed);
                    }
                    this.updateUI();
                };

                document.getElementById('pauseBtn').onclick = (e) => {
                    this.isPaused = !this.isPaused;
                    e.target.innerText = this.isPaused ? "‚ñ∂ RESUME" : "‚è∏ PAUSE";
                    e.target.classList.toggle('paused');
                };

                document.querySelectorAll('.speedBtn').forEach(btn => {
                    btn.onclick = (e) => {
                        this.gameSpeed = parseFloat(e.target.dataset.speed);
                        document.querySelectorAll('.speedBtn').forEach(b => b.classList.remove('active'));
                        e.target.classList.add('active');
                    };
                });
            }

            updateUI() {
                document.getElementById('gold').innerText = this.gold;
                document.getElementById('lives').innerText = this.lives;
                document.getElementById('wave').innerText = this.wave;
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                if (!this.isPaused) {
                    const dt = this.clock.getDelta();
                    this.stars.rotation.y += 0.0005;

                    // Hover logic
                    this.raycaster.setFromCamera(this.mouse, this.camera);
                    const intersects = this.raycaster.intersectObjects(this.scene.children);
                    
                    if (this.hoveredObj) this.hoveredObj.material.emissiveIntensity = 0.2;
                    if (intersects.length > 0) {
                        const obj = intersects[0].object;
                        if (obj.userData.gridX !== undefined) {
                            this.hoveredObj = obj;
                            obj.material.emissiveIntensity = 1.0;
                        }
                    }

                    // Enemies
                    for(let i=this.enemies.length-1; i>=0; i--) {
                        const res = this.enemies[i].update(this.gameSpeed);
                        if (res === 'escaped') {
                            this.lives--;
                            this.scene.remove(this.enemies[i].mesh);
                            this.enemies.splice(i, 1);
                            this.updateUI();
                        }
                    }

                    // Towers
                    this.towers.forEach(t => {
                        const target = t.update(this.enemies, Date.now(), this.gameSpeed);
                        if (target && target.takeDamage(1)) {
                            this.gold += 10;
                            this.updateUI();
                        }
                    });
                }
                this.composer.render();
            }
        }

        new GameManager();
    </script>
</body>
</html>
